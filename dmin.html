<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Détection de collisions</title>
	<link href="media/bootstrap.css" rel="stylesheet">
	<link href="media/style.css" rel="stylesheet">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<script src="media/jquery-2.1.0.min.js"></script>
	<script src="media/bootstrap.js"></script>
	<script type="text/x-mathjax-config">
		MathJax.Hub.Config({
			"tex2jax" : { "inlineMath" : [['$','$'], ['\\(','\\)']] },
			"HTML-CSS" : { "scale" : 85 }
		});
	</script>
	<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
	<script src="media/processing.js"></script>
<script 
<script>
	var frameworkJs = "class Line2D extends Object2D {\n\tPoint2D a;\n\tPoint2D b;\n\n\tLine2D(Point2D na, Point2D nb) {\n\t\ta = na;\n\t\tb = nb;\n\t}\n\n\tstatic Line2D fromVector(Point2D o, PVector dir) {\n\t\treturn new Line2D(a, new Point2D(o.x + dir.x, o.y + dir.y));\n\t}\n\t\n\tPVector direction() {\n\t\tPVector dir = toPVector();\n\t\tdir.normalize();\n\t\treturn dir;\n\t}\n\t\n\tPoint2D firstPoint() {\n\t\treturn a;\n\t}\n\t\n\tPoint2D secondPoint() {\n\t\treturn b;\n\t}\n\t\n\tPVector toPVector() {\n\t\treturn new PVector(b.x - a.x, b.y - a.y);\n\t}\n\t\n\tprotected void draw_() {\t\t\n\t\tnoFill();\n\t\tstroke(strokeColor);\n\n\t\tPoint2D p1 = pointAtX(0);\n\t\tPoint2D p2 = pointAtX(width);\n\t\tline(p1.x, p1.y, p2.x, p2.y);\n\t}\n\t\t\n\tvoid translation(PVector v) {\n\t\ta.translation(v);\n\t\tb.translation(v);\n\t}\n\t\n\tPVector center() {\n\t\treturn new PVector(\n\t\t\ta.x + (b.x - a.x)\/2,\n\t\t\ta.y + (b.y - a.y)\/2\n\t\t);\n\t}\n\t\n\tboolean isXAligned() {\n\t\treturn (a.y == b.y);\n\t}\n\t\n\tboolean isYAligned() {\n\t\treturn (a.x == b.x);\n\t}\n\t\n\tfloat slope() {\n\t\tPVector v = toPVector();\n\t\treturn v.y \/ v.x;\n\t}\n\t\n\tfloat offset() {\n\t\treturn a.y - slope()*a.x;\n\t}\n\t\n\tvoid reverse() {\n\t\tPoint2D tmp = a;\n\t\ta = b;\n\t\tb = tmp;\n\t}\n\t\n\tint side(Point2D p) {\n\t\treturn Point2D.turn(a, b, p);\n\t}\n\t\n\tPoint2D pointAtX(float x) {\n\t\tfloat y = slope()*x + offset();\n\t\treturn new Point2D(x, y);\n\t}\n\t\n\tSegment2D orthogonalRejection(Point2D p) {\n\t\tPVector dir = direction();\n\t\tPVector pa = PVector.sub(a.toPVector(), p.toPVector());\n\t\tfloat projectionLength = pa.dot(dir);\n\t\tPVector projection = PVector.mult(dir, projectionLength);\n\t\tPVector rejection = PVector.sub(pa, projection);\n\t\treturn Segment2D.fromVector(p, rejection);\n\t}\n\t\n\tfloat orthogonalDistance(Point2D p) {\n\t\treturn orthogonalRejection(p).norm();\n\t}\n\t\n\tboolean isUnderMouse() {\n\t\tPoint2D m = new Point2D(mouseX, mouseY);\n\t\treturn (orthogonalDistance(m) <= 3)\n\t}\n\t\n\tfloat orientedOrthogonalDistance(Point2D p, Point2D v) {\n\t\tfloat d = orthogonalDistance(p);\n\t\tif(side(p) != side(v)) return -d;\n\t\treturn d;\n\t}\n\t\n\tPoint2D lineIntersection(Line2D l2) {\n\t\tfloat x1 = a.x, y1 = a.y;\n\t\tfloat x2 = b.x, y2 = b.y;\n\t\tfloat x3 = l2.a.x, y3 = l2.a.y;\n\t\tfloat x4 = l2.b.x, y4 = l2.b.y;\n\t\treturn new Point2D(\n\t\t\t  ( (x1*y2 - y1*x2)*(x3 - x4) - (x1 - x2)*(x3*y4 - y3*x4) )\n\t\t\t\/ ( (x1 - x2)*(y3 - y4) - (y1 - y2)*(x3 - x4) ),\n\t\t\t\n\t\t\t  ( (x1*y2 - y1*x2)*(y3 - y4) - (y1 - y2)*(x3*y4 - y3*x4) )\n\t\t\t\/ ( (x1 - x2)*(y3 - y4) - (y1 - y2)*(x3 - x4) )\n\t\t);\n\t}\n\t\n\tPoint2D projection(Point2D p) {\n\t\tPVector ab = toPVector();\n\t\tPVector ap = Point2D.makePVector(a, p);\n\t\tab.normalize();\n\t\tfloat l = PVector.dot(ab, ap);\n\t\tab.mult(l);\n\t\treturn new Point2D(a.x + ab.x, a.y + ab.y);\n\t}\n}\n\nclass Object2D {\n\tboolean visible;\n\tcolor strokeColor;\n\tString label;\n\tboolean draggable;\n\tboolean kinetic;\n\tPVector velocity;\n\t\n\tObject2D() {\n\t\tvelocity = new PVector(0, 0);\n\t\tdraggable = true;\n\t\tkinetic = false;\n\t\tvisible = true;\n\t\tstrokeColor = color(0);\n\t\tlabel = null;\n\t}\n\t\n\tObject2D update() {\n\t\treturn null;\n\t}\n\t\n\tvoid draw() {\n\t\tif(! visible) return;\n\t\tdraw_();\n\t\tif(label != null) {\n\t\t\tfill(strokeColor);\n\t\t\tPVector c = center();\n\t\t\ttextAlign(CENTER);\n\t\t\ttext(label, c.x + 5, c.y + 10);\n\t\t}\n\t}\n\t\n\tprotected void draw_() { }\n\tPVector center() { return null; }\n\tvoid translation(PVector v) { }\n\t\n\tboolean isUnderMouse() { return false; }\n}\n\nclass Point2D extends Object2D {\n\tfloat x;\n\tfloat y;\n\tPoint2D next;\n\tPoint2D previous;\n\t\n\tstatic Point2D fromPVector(PVector v) {\n\t\treturn new Point2D(v.x, v.y);\n\t}\n\t\n\tstatic Point2D makePVector(Point2D a, Point2D b) {\n\t\treturn new PVector(b.x - a.x, b.y - a.y);\n\t}\n\t\n\tPoint2D(float nx, float ny) {\n\t\tx = nx;\n\t\ty = ny;\n\t}\n\t\n\tprotected void draw_() {\t\t\n\t\tnoStroke();\n\t\tfill(strokeColor);\n\n\t\tellipseMode(CENTER);\n\t\tellipse(x, y, 3, 3);\n\t}\n\t\n\tboolean isUnderMouse() {\n\t\tfloat minOffset = 3;\n\t\tfloat dx = abs(x - mouseX);\n\t\tfloat dy = abs(y - mouseY);\n\t\treturn (dx <= minOffset) && (dy <= minOffset);\n\t}\n\t\n\tPVector center() {\n\t\treturn toPVector();\n\t}\n\t\n\tPVector toPVector() {\n\t\treturn new PVector(x, y);\n\t}\n\t\n\tvoid translation(PVector v) {\n\t\tx += v.x;\n\t\ty += v.y;\n\t}\n\t\n\tstatic int turn(Point2D a, Point2D b, Point2D c) {\n\t\tPVector ba = new PVector(a.x - b.x, a.y - b.y);\n\t\tPVector bc = new PVector(c.x - b.x, c.y - b.y);\n\t\tPVector cross = ba.cross(bc);\n\t\treturn sign(cross.z);\n\t}\n\t\n\tstatic float angle(Point2D a, Point2D b, Point2D c) {\n\t\tPVector ba = new PVector(a.x - b.x, a.y - b.y); ba.normalize();\n\t\tPVector bc = new PVector(c.x - b.x, c.y - b.y); bc.normalize();\n\t\tfloat an = acos(PVector.dot(ba, bc));\n\t\tif(PVector.cross(ba, bc).z < 0) return TWO_PI - an;\n\t\telse return an;\n\t}\n\n\tstatic float sqDistance(Point2D a, Point2D b) {\n\t\tfloat x = a.x - b.x;\n\t\tfloat y = a.y - b.y;\n\t\treturn x*x + y*y;\n\t}\n\t\n\tstatic float distance(Point2D a, Point2D b) {\n\t\treturn sqrt(sqDistance(a, b));\n\t}\n\t\n\tstatic void sortPoints(ArrayList pts, int coordinate, boolean ascending) {\n\t\tboolean cont = false;\n\t\tint lim = pts.size();\n\t\tdo {\n\t\t\tfor(int i = 1; i < lim; ++i) {\n\t\t\t\tPoint2D p1 = pts.get(i - 1);\n\t\t\t\tPoint2D p2 = pts.get(i);\n\t\t\t\tboolean swap = false;\n\t\t\t\tif(coordinate == 0) swap = (p1.x > p2.x);\n\t\t\t\telse if(coordinate == 1) swap = (p1.y > p2.y);\n\t\t\t\tif(! ascending) swap = !swap;\n\t\t\t\tif(swap) {\n\t\t\t\t\tcont = true;\n\t\t\t\t\tpts.set(i - 1, p2);\n\t\t\t\t\tpts.set(i, p1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t--lim;\n\t\t} while(cont && lim);\n\t}\n}\n\nclass Polygon2D extends Object2D {\n\tArrayList points;\n\tboolean hasFillColor;\n\tcolor fillColor;\n\t\n\tstatic Polygon2D generateRandom(int nbPoints, PVector low, PVector high) {\n\t\tPolygon2D poly = new Polygon2D;\n\t\tfor(int i = 0; i < nbPoints; ++i) {\n\t\t\tfloat x = random(low.x, high.x);\n\t\t\tfloat y = random(low.y, high.y);\n\t\t\tPoint2D pt = new Point2D(x, y);\n\t\t\tpoly.points.add(pt);\n\t\t}\n\t\tpoly.linkPoints();\n\t\tpoly.randomShiftPoints();\n\t\treturn poly;\n\t}\n\t\n\tstatic Polygon2D generateRandomConvexWithMaximalNumberOfPoints(int nbPoints, PVector low, PVector high) {\n\t\tPolygon2D poly = Polygon2D.generateRandom(nbPoints, low, high);\n\t\tPolygon2D cpoly = poly.convexHull();\n\t\tcpoly.randomShiftPoints();\n\t\treturn cpoly;\n\t}\n\n\tstatic Polygon2D generateRandomConvex(int nbPoints, PVector low, PVector high) {\n\t\tPolygon2D poly = Polygon2D.generateRandomConvexWithMaximalNumberOfPoints(2 * nbPoints, low, high);\n\t\tfloat m = 2;\n\t\twhile(poly.points.size() < nbPoints) {\n\t\t\tm += 0.5;\n\t\t\tpoly = Polygon2D.generateRandomConvexWithMaximalNumberOfPoints(m * nbPoints, low, high);\n\t\t}\n\t\tfor(int remaining = poly.points.size() - nbPoints; remaining > 0; --remaining) {\n\t\t\tint i = floor(random(0, poly.points.size() - 1));\n\t\t\tpoly.points.remove(i);\n\t\t}\n\t\tpoly.linkPoints();\n\t\treturn poly;\n\t}\n\t\n\tPolygon2D() {\n\t\tpoints = new ArrayList();\n\t}\n\t\n\tPolygon2D(ArrayList pts) {\n\t\tpoints = new ArrayList(pts);\n\t\tlinkPoints();\n\t}\n\t\n\tboolean isConvex() {\n\t\tPoint p1 = points.get(points.size() - 2);\n\t\tPoint p2 = points.get(points.size() - 1);\n\t\tPoint p3 = points.get(0);\n\t\tint need_sign = Point2D.turn(p1, p2, p3);\n\t\tfor(int i = 1; i < points.size(); ++i) {\n\t\t\tp1 = p2;\n\t\t\tp2 = p3;\n\t\t\tp3 = points.get(i);\n\t\t\tint sign = Point2D.turn(p1, p2, p3);\n\t\t\tif(sign != need_sign) return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tvoid linkPoints() {\n\t\tfor(int i = 1; i < points.size(); ++i) {\n\t\t\tpoints.get(i - 1).next = points.get(i);\n\t\t\tpoints.get(i).previous = points.get(i - 1);\n\t\t}\n\t\tpoints.get(points.size() - 1).next = points.get(0);\n\t\tpoints.get(0).previous = points.get(points.size() - 1);\n\t}\n\t\n\tPVector center() {\n\t\tPVector c = new PVector(0, 0);\n\t\tfor(int i = 0; i < points.size(); ++i) {\n\t\t\tc.add(points.get(i).toPVector());\n\t\t}\n\t\tc.div(points.size());\n\t\treturn c;\n\t}\n\t\n\tvoid translation(PVector v) {\n\t\tfor(int i = 0; i < points.size(); ++i) {\n\t\t\tpoints.get(i).translation(v);\n\t\t}\n\t}\n\t\n\tprotected void draw_() {\n\t\tif(hasFillColor) fill(fillColor);\n\t\telse noFill();\n\t\tstroke(strokeColor);\n\n\t\tbeginShape();\n\t\tfor(int i = 0; i < points.size(); ++i) {\n\t\t\tPoint2D pt = points.get(i);\n\t\t\tvertex(pt.x, pt.y);\n\t\t}\n\t\tendShape(CLOSE);\n\t}\n\n\t\n\tPolygon2D convexHull() {\n\t\t\/\/ from http:\/\/www.cs.uu.nl\/docs\/vakken\/ga\/slides1.pdf\n\t\tArrayList pts = new ArrayList(points);\n\t\t\n\t\tPoint2D.sortPoints(pts, 0, true);\n\t\t\t\t\n\t\tArrayList upper = new ArrayList();\n\t\tupper.add(pts.get(0)); upper.add(pts.get(1));\n\t\tfor(int i = 2; i < pts.size(); ++i) {\n\t\t\tupper.add(pts.get(i));\n\t\t\tint l = upper.size() - 1;\n\t\t\twhile(upper.size() > 2 && Point2D.turn(upper.get(l-2), upper.get(l-1), upper.get(l)) > 0) {\n\t\t\t\tupper.remove(l-1);\n\t\t\t\tl = upper.size() - 1;\n\t\t\t}\n\t\t}\n\t\t\t\t\t\t\n\t\tPoint2D.sortPoints(pts, 0, false);\n\t\tArrayList lower = new ArrayList();\n\t\tlower.add(pts.get(0)); lower.add(pts.get(1));\n\t\tfor(int i = 2; i < pts.size(); ++i) {\n\t\t\tlower.add(pts.get(i));\n\t\t\tint l = lower.size() - 1;\n\t\t\twhile(lower.size() > 2 && Point2D.turn(lower.get(l-2), lower.get(l-1), lower.get(l)) > 0) {\n\t\t\t\tlower.remove(l-1);\n\t\t\t\tl = lower.size() - 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 1; i < lower.size() - 1; ++i) {\n\t\t\tupper.add(lower.get(i));\n\t\t}\n\t\t\n\t\treturn new Polygon2D(upper);\n\t}\n\t\n\tArrayList segments() {\n\t\tArrayList segments = new ArrayList();\n\t\tfor(int i = 1; i < points.size(); ++i) {\n\t\t\tsegments.add(new Segment2D(points.get(i - 1), points.get(i)));\n\t\t}\n\t\tsegments.add(new Segment2D(points.get(points.size() - 1), points.get(0)));\n\t\treturn segments;\n\t}\n\t\n\tSegment2D segment(int i) {\n\t\ti = i % points.size();\n\t\tif(i < 0) i += points.size();\n\t\tif(i < points.size() - 1) return new Segment2D(points.get(i), points.get(i + 1));\n\t\telse return new Segment2D(points.get(points.size() - 1), points.get(0));\n\t}\n\t\n\tboolean containsPoint(PVector v) {\n\t\tboolean c = false;\n\t\tint j = points.size() - 1;\n\t\tfor(int i = 0; i < points.size(); j = i++) {\n\t\t\tPoint2D pi = points.get(i);\n\t\t\tPoint2D pj = points.get(j);\n\t\t\tif(\n\t\t\t\t((pi.y > v.y) != (pj.y > v.y)) &&\n\t\t\t\t(v.x < (pj.x-pi.x) * (v.y-pi.y) \/ (pj.y-pi.y) + pi.x)\n\t\t\t) c = !c;\n\t\t}\n\t\treturn c;\n\t}\n\t\n\tboolean isUnderMouse() {\n\t\treturn containsPoint(new PVector(mouseX, mouseY));\n\t}\n\t\n\tboolean isClockwise() {\n\t\tfloat sum = 0;\n\t\tArrayList seg = segments();\n\t\tfor(int i = 0; i < seg.size(); ++i) {\n\t\t\tSegment2D s = seg.get(i);\n\t\t\tsum += (s.b.x - s.a.x) * (s.b.y + s.a.y);\n\t\t}\n\t\treturn (sum > 0);\n\t}\n\t\n\tArrayList reversedPoints() {\n\t\tArrayList reversed = new ArrayList;\n\t\tfor(int i = points.size() - 1; i >= 0; --i) {\n\t\t\treversed.add(points.get(i));\n\t\t}\n\t\treturn reversed;\n\t}\n\t\n\tvoid reversePoints() {\n\t\tpoints = reversedPoints();\n\t\tlinkPoints();\n\t}\n\t\n\tvoid shiftPoints(int s) {\n\t\tArrayList newPoints = new ArrayList;\n\t\t\n\t\tfor(int i = 0; i < points.size(); ++i) {\n\t\t\tint j = (i - s) % points.size();\n\t\t\tif(s > i) j += points.size();\n\t\t\tnewPoints.add(points.get(j));\n\t\t}\n\t\tpoints = newPoints;\n\t}\n\t\n\tvoid randomShiftPoints() {\n\t\tshiftPoints(floor(random(1, points.size() - 1)));\n\t}\n\t\n\tfloat pointOrientedDistanceToLine(int i, Line2D line, Point2D v) {\n\t\treturn line.orientedOrthogonalDistance(points.get(i), v);\n\t}\n\t\n\tfloat pointOrientedDistanceToLineG(int i, Line2D line, Point2D v) {\n\t\tfloat f = pointOrientedDistanceToLine(i, line, v);\n\t\tfloat f1 = pointOrientedDistanceToLine(0, line, v);\n\t\tfloat fn = pointOrientedDistanceToLine(points.size() - 1, line, v);\n\t\tfloat t = f1 + (fn - f1)*(i\/(points.size() - 1));\n\t\treturn min(f, t);\n\t}\n\t\n\tfloat segmentPointsOrientedDistancesDifference(int i, Line2D line, Point2D v) {\n\t\tSegment2D seg = segment(i);\n\t\tfloat da = pointOrientedDistanceToLine(i, line, v);\n\t\tfloat db = pointOrientedDistanceToLine((i + 1) % points.size(), line, v);\n\t\treturn db - da;\n\t}\n\t\n\tfloat segmentPointsOrientedDistancesDifferenceG(int i, Line2D line, Point2D v) {\n\t\tSegment2D seg = segment(i);\n\t\tfloat da = pointOrientedDistanceToLineG(i, line, v);\n\t\tfloat db = pointOrientedDistanceToLineG((i + 1) % points.size(), line, v);\n\t\treturn db - da;\n\t}\n\t\n\tfloat lineDistance(Line2D line, Point2D v) {\n\t\tint mn = 0, mx = points.size() - 1;\n\t\twhile(abs(mn - mx) > 1) {\n\t\t\tint i = floor(mn + (mx - mn)\/2);\n\t\t\tfloat dfi = segmentPointsOrientedDistancesDifferenceG(i, line, v);\n\t\t\tif(dfi < 0) mn = i;\n\t\t\telse mx = i;\n\t\t}\n\t\tw = mn + 1;\n\t\treturn pointOrientedDistanceToLine(w, line, v);\n\t}\n\t\n\tint[] lineIntersectionSegmentIndices(Line2D line, Point2D v) {\n\t\tif(v == null) v = points.get(0);\n\t\t\n\t\tfloat f1 = pointOrientedDistanceToLineG(0, line, v);\n\t\tfloat f2 = pointOrientedDistanceToLineG(1, line, v);\n\t\tfloat fn = pointOrientedDistanceToLineG(points.size() - 1, line, v);\n\t\tint w; float fw;\n\t\t\n\t\tint mn = 0, mx = points.size() - 1;\n\t\twhile(abs(mn - mx) > 1) {\n\t\t\tint i = floor(mn + (mx - mn)\/2);\n\t\t\tfloat dfi = segmentPointsOrientedDistancesDifferenceG(i, line, v);\n\t\t\tif(dfi < 0) mn = i;\n\t\t\telse mx = i;\n\t\t}\n\t\tw = mn + 1;\n\t\tfw = pointOrientedDistanceToLine(w, line, v);\n\n\t\tif(fw > 0) {\n\t\t\tint[] inter = {};\n\t\t\treturn inter;\n\t\t} else if(fw == 0) {\n\t\t\tint[] inter = { w };\n\t\t\treturn inter;\n\t\t} else {\n\t\t\tint[] inter = {null, null};\n\n\t\t\tint mn = 0, mx = w;\n\t\t\twhile(abs(mn - mx) > 1) {\n\t\t\t\tint i = floor(mn + (mx - mn)\/2);\n\t\t\t\tfloat fi = pointOrientedDistanceToLine(i, line, v);\n\t\t\t\tif(fi > 0) mn = i;\n\t\t\t\telse mx = i;\n\t\t\t}\n\t\t\tinter[0] = mn;\n\n\t\t\tint mn = w, mx = points.size();\n\t\t\twhile(abs(mn - mx) > 1) {\n\t\t\t\tint i = floor(mn + (mx - mn)\/2);\n\t\t\t\tfloat fi = pointOrientedDistanceToLine(i, line, v);\n\t\t\t\tif(fi < 0) mn = i;\n\t\t\t\telse mx = i;\n\t\t\t}\n\t\t\tinter[1] = mn;\n\t\t\t\n\t\t\treturn inter;\n\t\t}\n\t}\n\t\n\tSegment2D[] lineIntersectionSegments(Line2D l, Point2D v) {\n\t\tint[] segs = lineIntersectionSegmentIndices(l, v);\n\t\tif(segs.length == 0) {\n\t\t\tSegment2D[] segs = {};\n\t\t\treturn segs;\n\t\t} else if(segs.length == 1) {\n\t\t\tSegment2D[] segs = { segment(segs[0]) };\n\t\t\treturn segs;\n\t\t} else if(segs.length == 2) {\n\t\t\tSegment2D[] segs = { segment(segs[0]), segment(segs[1]) };\n\t\t\treturn segs;\n\t\t}\n\t}\n\t\n\tPoint2D[] lineIntersection(Line2D l, Point2D v) {\n\t\tSegment2D[] segs = lineIntersectionSegments(l, v);\n\t\tif(segs.length == 0) {\n\t\t\tPoint2D[] pts = {};\n\t\t\treturn pts;\n\t\t} else if(segs.length == 1) {\n\t\t\tPoint2D[] pts = { segs[0].lineIntersection(l) };\n\t\t\treturn pts;\n\t\t} else if(segs.length == 2) {\n\t\t\tPoint2D[] pts = { segs[0].lineIntersection(l), segs[1].lineIntersection(l) };\n\t\t\treturn pts;\n\t\t}\n\t}\n\t\n\tSegment2D[] rayItersectionSegments(Ray2D r, Point2D v) {\n\t\tSegment2D[] segs = lineIntersectionSegments(r, v);\n\t\tif(segs == null) return null;\n\t\tPoint2D p1 = r.lineIntersection(segs[0]);\n\t\tPoint2D p2 = r.lineIntersection(segs[1]);\n\t\tif(p1 != null && p2 != null) {\n\t\t\treturn segs;\n\t\t} else if(p1 != null) {\n\t\t\tSegment2D[] res = { segs[0] }; return res;\n\t\t} else if(p1 != null) {\n\t\t\tSegment2D[] res = { segs[1] }; return res;\n\t\t}\n\t}\n\t\n\tRay2D[] pencil(Polygon2D Q) {\n\t\tPoint2D qc = Point2D.fromPVector(Q.center());\n\t\tPoint2D p1 = points.get(0);\n\t\tSegment2D[] segs = Q.lineIntersectionSegments(new Line2D(qc, p1));\n\t\tif(segs == null) return null;\n\t\n\t\tPoint2D t, u;\n\t\n\t\tfloat max_a = 0.0;\n\t\tPVector p1qc = new PVector(qc.x - p1.x, qc.y - p1.y);\n\t\tfor(Point2D q = segs[1].b; q != segs[0].a.next; q = q.next) {\n\t\t\tPVector p1q = new PVector(q.x - p1.x, q.y - p1.y);\n\t\t\tfloat a = PVector.angleBetween(p1qc, p1q);\n\t\t\tif(a > max_a) { max_a = a; t = q; }\n\t\t}\n\t\t\n\t\tmax_a = 0.0;\n\t\tfor(Point2D q = segs[0].b; q != segs[1].a.next; q = q.next) {\n\t\t\tPVector p1q = new PVector(q.x - p1.x, q.y - p1.y);\n\t\t\tfloat a = PVector.angleBetween(p1qc, p1q);\n\t\t\tif(a > max_a) { max_a = a; u = q; }\n\t\t}\n\t\t\n\t\tRay2D[] p = {null, null};\n\t\tif(Point2D.turn(t, p1, u) == Point2D.turn(t, t.next, t.next.next)) {\n\t\t\tp[0] = new Ray2D(p1, t); p[1] = new Ray2D(p1, u);\n\t\t} else {\n\t\t\tp[1] = new Ray2D(p1, t); p[0] = new Ray2D(p1, u);\n\t\t}\n\n\t\treturn p;\n\t}\n\t\n\tObject2D[] pencilOrIntersectionPoint(Polygon2D Q) {\n\t\tPoint2D qc = Point2D.fromPVector(Q.center());\n\t\tPoint2D p1 = points.get(0);\n\t\tLine2D l = new Line2D(qc, p1);\n\t\tPoint2D[] ab = Q.lineIntersection(l);\n\t\tPVector p1a = (new Segment2D(p1, ab[0])).toPVector();\n\t\tPVector p1b = (new Segment2D(p1, ab[1])).toPVector();\n\t\tif(PVector.dot(p1a, p1b) < 0) {\n\t\t\tObject2D ret = { null, p1 };\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\treturn pencil(Q);\n\t}\n\t\n\tint indexModulo(int index) {\n\t\tboolean negative = (index < 0);\n\t\tindex %= points.size();\n\t\tif(negative) index += points.size();\n\t\treturn index;\n\t}\n\n\tArrayList pencilOwnPolyline(Ray2D[] pencil) {\n\t\tif(pencil[0].a != pencil[1].a) { console.log(\"rays don't have same origin\"); return null; }\n\t\tPoint2D o = pencil[0].a; \/\/ == pencil.b\n\t\tPoint2D v = o.next; \/\/ must not be o\n\t\tint n = points.size();\n\t\t\n\t\tint first = -1, last = -1;\n\t\tPoint2D firstp = o, lastp = o;\n\t\t\n\t\tint[] inter1 = lineIntersectionSegmentIndices(pencil[0], v);\n\t\t\n\t\tif(inter1.length == 2) {\n\t\t\tif(inter1[0] == 0 || inter1[0] == n) first = inter1[1];\n\t\t\telse first = inter1[0];\n\n\t\t\tfirstp = segment(first).lineIntersection(pencil[0]);\n\t\t\tif(PVector.dot(pencil[0].toPVector(), Point2D.makePVector(o, firstp)) < 0) {\n\t\t\t\tfirstp = o; first = -1;\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tint[] inter2 = lineIntersectionSegmentIndices(pencil[1], v);\n\t\tif(inter2.length == 2) {\n\t\t\tif(inter2[0] == 0 || inter2[0] == n) last = inter2[1];\n\t\t\telse last = inter2[0];\n\n\t\t\tlastp = segment(last).lineIntersection(pencil[1]);\n\t\t\tif(PVector.dot(pencil[1].toPVector(), Point2D.makePVector(o, lastp)) < 0) {\n\t\t\t\tlastp = o; last = -1;\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\tif(first == -1 && last == -1) {\n\t\t\tif(! Ray2D.enclosePoints(pencil, o.next)) return new ArrayList;\t\t\n\t\t} else if(first == -1) {\n\t\t\tif(Ray2D.enclosePoints(pencil, o.next)) first = 0;\n\t\t\telse first = n;\n\t\t} else if(last == -1) {\n\t\t\tif(Ray2D.enclosePoints(pencil, o.next)) last = 0;\n\t\t\telse last = n;\n\t\t}\n\t\t\n\t\tif(first > last) {\n\t\t\tint tmp = first;\n\t\t\tfirst = last;\n\t\t\tlast = tmp;\n\t\t\tPoint2D tmpp = firstp;\n\t\t\tfirstp = lastp;\n\t\t\tlastp = tmpp;\n\t\t}\n\t\t\n\t\tPoint2D secondp = (first == -1 ? o.next : points.get(indexModulo(first + 1)));\n\t\tPoint2D secondlastp = (last == -1 ? o.previous : points.get(indexModulo(last)));\n\n\t\t\n\t\tArrayList pts = new ArrayList;\n\t\tpts.add(firstp);\n\t\tfor(Point2D pt = secondp; pt != secondlastp.next; pt = pt.next) {\n\t\t\tpts.add(pt);\n\t\t}\n\t\tpts.add(lastp);\n\t\t\n\t\treturn pts;\n\t}\n\t\n\tSegment2D minimalDistance(Polygon2D Q) {\n\t\treturn minimalDistanceDebug(Q, 0, false);\n\t}\n\t\n\tSegment2D minimalDistanceDebug(Polygon2D Q, int steps, boolean debug) {\n\t\tPolygon2D P = this;\n\t\t\n\t\tRay2D[] pencilP = P.pencil(Q);\n\t\tRay2D[] pencilQ = Q.pencil(P);\n\t\t\n\t\tArrayList ps = new ArrayList;\n\t\tfor(Point2D p = pencilQ[0].b; p != pencilQ[1].b.next; p = p.next) ps.add(p);\n\n\t\tArrayList qs = new ArrayList;\n\t\tfor(Point2D q = pencilP[0].b; q != pencilP[1].b.next; q = q.next) qs.add(q);\n\n\t\tint p1 = 0, p2 = ps.size() - 1, np = ps.size();\n\t\tint q1 = 0, q2 = qs.size() - 1, nq = qs.size();\n\n\t\tif(debug) {\n\t\t\tfor(int i = points.size() - 1; i >= 0; --i) { points.get(i).strokeColor = #000000; points.get(i).label = i; }\t\n\t\t\tfor(int i = Q.points.size() - 1; i >= 0; --i) { Q.points.get(i).strokeColor = #000000; Q.points.get(i).label = i; }\n\t\t}\n\t\t\n\t\tint currStep = 0;\n\t\twhile(np > 2 || nq > 2) {\n\t\t\tif(++currStep == steps) break;\n\t\t\t\n\t\t\tint oldnp = np, oldnq = nq;\n\t\t\t\n\t\t\tint mpi = p1 + ceil((p2-p1) \/ 2);\n\t\t\tint mqi = q1 + ceil((q2-q1) \/ 2);\n\t\t\tPoint2D mp = ps.get(mpi);\n\t\t\tPoint2D mq = qs.get(mqi);\n\t\t\tif(mp == null || mq == null) return null;\n\t\t\t\t\t\t\n\t\t\tfloat a1 = Point2D.angle(mq, mp, mp.previous);\n\t\t\tfloat a2 = Point2D.angle(mp.next, mp, mq);\n\t\t\tif(a1 > PI && a2 > PI) { a1 -= TWO_PI; a2 -= TWO_PI; }\n\t\t\t\t\n\t\t\tfloat b1 = Point2D.angle(mq.previous, mq, mp);\n\t\t\tfloat b2 = Point2D.angle(mp, mq, mq.next);\n\t\t\tif(b1 > PI && b2 > PI) { b1 -= TWO_PI; b2 -= TWO_PI; }\n\t\t\t\n\t\t\t\/\/\/\/\/\/\/\/\/\/\/\/ DEBUG \/\/\/\/\/\/\/\/\/\/\/\/\n\t\t\tif(debug && currStep == steps-1) {\n\t\t\t\tSegment2D dseg = new Segment2D(mp, mq);\n\t\t\t\tdseg.label = currStep;\n\t\t\t\tdseg.draw();\t\n\t\n\t\t\t\tps.get(p1).strokeColor = #0000ff;\n\t\t\t\tps.get(p1).label = \"P1\";\n\t\t\t\tps.get(p2).strokeColor = #ff0000;\n\t\t\t\tps.get(p2).label = \"P2\";\n\t\t\t\t\n\t\t\t\tqs.get(q1).strokeColor = #0000ff;\n\t\t\t\tqs.get(q1).label = \"Q1\";\n\t\t\t\tqs.get(q2).strokeColor = #ff0000;\n\t\t\t\tqs.get(q2).label = \"Q2\";\n\t\t\t\t\n\t\t\t\tstroke(50);\n\t\t\t\tfloat d = 180.0 \/ PI;\n\t\t\t\ttextAlign(LEFT);\n\t\t\t\ttext(\"a2 = \" + formatNumber(a2*d, 2), mp.x + 5, mp.y - 15);\n\t\t\t\ttext(\"a1 = \" + formatNumber(a1*d, 2), mp.x + 5, mp.y + 15);\n\t\t\t\ttextAlign(RIGHT);\n\t\t\t\ttext(\"b2 = \" + formatNumber(b2*d, 2), mq.x - 5, mq.y - 15);\n\t\t\t\ttext(\"b1 = \" + formatNumber(b1*d, 2), mq.x - 5, mq.y + 15);\n\t\t\t}\n\t\t\t\/\/\/\/\/\/\/\/\/\/\/\/ END DEBUG \/\/\/\/\/\/\/\/\/\/\/\/\n\n\t\t\tif(np == 1) {\n\t\t\t\tif(debug) console.log(\"P: one vertex\");\n\t\t\t\tif(b1 >= HALF_PI) q1 = mqi;\n\t\t\t\tif(b2 >= HALF_PI) q2 = mqi;\n\t\t\t\t\n\t\t\t} else if(nq == 1) {\n\t\t\t\tif(debug) console.log(\"Q: one vertex\");\n\t\t\t\tif(a1 >= HALF_PI) p1 = mpi;\n\t\t\t\tif(a2 >= HALF_PI) p2 = mpi;\n\t\t\t\t\n\t\t\t} else if(np == 2) {\n\t\t\t\tif(debug) console.log(\"P: two vertices\");\n\t\t\t\tif(a1 > 0) {\n\t\t\t\t\tif(a1 + b1 > PI) {\n\t\t\t\t\t\tif(a1 >= HALF_PI) p1 = p2;\n\t\t\t\t\t\tif(b1 >= HALF_PI) q1 = mqi;\n\t\t\t\t\t}\n\t\t\t\t\tif(b2 >= HALF_PI) q2 = mqi;\n\t\t\t\t\tif(a1 < b2 && b2 < HALF_PI) {\n\t\t\t\t\t\tSegment2D p1p2seg = new Segment2D(ps.get(p1), ps.get(p2));\n\t\t\t\t\t\tif(p1p2seg.projectionIsOnSegment(mq)) q2 = mqi;\n\t\t\t\t\t\telse p2 = p1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tp2 = p1;\n\t\t\t\t\tif(b1 >= PI) q1 = mqi;\n\t\t\t\t\tif(b2 >= PI) q2 = mqi;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else if(nq == 2) {\n\t\t\t\tif(debug) console.log(\"Q: two vertices\");\n\t\t\t\tif(b2 > 0) {\n\t\t\t\t\tif(a1 + b1 > PI) {\n\t\t\t\t\t\tif(b1 >= HALF_PI) q1 = q2;\n\t\t\t\t\t\tif(a1 >= HALF_PI) p1 = mpi;\n\t\t\t\t\t}\n\t\t\t\t\tif(a2 >= HALF_PI) p2 = mpi;\n\t\t\t\t\tif(b1 < a2 && a2 < HALF_PI) {\n\t\t\t\t\t\tSegment2D q1q2seg = new Segment2D(qs.get(q1), qs.get(q2));\n\t\t\t\t\t\tif(q1q2seg.projectionIsOnSegment(mp)) p2 = mpi;\n\t\t\t\t\t\telse q2 = q1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tq2 = q1;\n\t\t\t\t\tif(a1 >= PI) p1 = mpi;\n\t\t\t\t\tif(a2 >= PI) p2 = mpi;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else if(a1 >= 0 && a2 >= 0 && b1 >= 0 && b2 >= 0) {\n\t\t\t\tif(debug) console.log(\"> 3 vertices: all angles positive\");\n\t\t\t\tif(a1 + b1 > PI) {\n\t\t\t\t\tif(a1 >= HALF_PI) p1 = mpi;\n\t\t\t\t\tif(b1 >= HALF_PI) q1 = mqi;\n\t\t\t\t}\n\t\t\t\tif(a2 + b2 > PI) {\n\t\t\t\t\tif(a2 >= HALF_PI) p2 = mpi;\n\t\t\t\t\tif(b2 >= HALF_PI) q2 = mqi;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else if(a1 < 0) {\n\t\t\t\tif(debug) console.log(\"> 3 vertices: a1 and a2 negative\");\n\t\t\t\tif(a1 > a2) p2 = mpi;\n\t\t\t\telse p1 = mpi;\n\t\t\t\tif(b1 > PI) q1 = mqi;\n\t\t\t\tif(b2 > PI) q2 = mqi;\n\t\t\t\t\n\n\t\t\t} else if(b1 < 0) {\n\t\t\t\tif(debug) console.log(\"> 3 vertices: b1 and b2 negative\");\n\t\t\t\tif(b1 > b2) q2 = mqi;\n\t\t\t\telse q1 = mqi;\n\t\t\t\tif(a1 > PI) p1 = mpi;\n\t\t\t\tif(a2 > PI) p2 = mpi;\n\t\t\t\t\n\t\t\t}\n\n\t\t\tnp = p2 - p1 + 1;\n\t\t\tnq = q2 - q1 + 1;\n\t\t\t\n\t\t\tif(np >= oldnp && nq >= oldnq) {\n\t\t\t\tif(debug) console.log(\"loop\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t\tif(debug) console.log(oldnp, oldnq, \"->\", np, nq);\n\t\t}\n\t\t\n\t\tif(debug) {\n\t\t\tps.get(p1).label = ps.get(p1).label + \" (P1)\";\n\t\t\tps.get(p2).label = ps.get(p2).label + \" (P2)\";\n\t\t\tqs.get(q1).label = qs.get(q1).label + \" (Q1)\";\n\t\t\tqs.get(q2).label = qs.get(q2).label + \" (Q2)\";\n\t\t}\n\t\t\n\t\tif(np > 2 || nq > 2) return null;\t\t\n\t\t\n\t\tPoint2D p1_ = ps.get(p1), p2_ = ps.get(p2), q1_ = qs.get(q1), q2_ = qs.get(q2);\n\t\tif(p1_ == null || p2_ == null || q1_ == null || q2_ == null) return null;\n\t\t\n\t\tif(np == 1 && nq == 1) {\n\t\t\tif(debug) console.log(\"two vertices\");\n\t\t\treturn new Segment2D(ps.get(p1), qs.get(q1));\n\t\t\t\n\t\t} else if(np == 1) {\n\t\t\tif(debug) console.log(\"edge in Q\");\n\t\t\tPoint2D r, q;\n\t\t\tSegment2D q1q2 = new Segment2D(q1_, q2_);\n\t\t\tif(q1q2.projectionIsOnSegment(p1_)) r = q1q2.projection(p1_); else r = q1_;\n\t\t\t\n\t\t\tfloat d1 = Point2D.sqDistance(q1_, p1_), d2 = Point2D.sqDistance(q2_, p1_), dr = Point2D.sqDistance(r, p1_);\n\t\t\tif(d1 < d2) { if(dr < d1) q = r; else q = q1_; }\n\t\t\telse { if(dr < d2) q = r; else q = q2_; }\n\t\t\t\n\t\t\treturn new Segment2D(p1_, q);\n\t\t\t\n\t\t} else if(nq == 1) {\n\t\t\tif(debug) console.log(\"edge in Q\");\n\t\t\tPoint2D r, p;\n\t\t\tSegment2D p1p2 = new Segment2D(p1_, p2_);\n\t\t\tif(p1p2.projectionIsOnSegment(q1_)) r = p1p2.projection(q1_); else r = p1_;\n\t\t\t\n\t\t\tfloat d1 = Point2D.sqDistance(p1_, q1_), d2 = Point2D.sqDistance(p2_, q1_), dr = Point2D.sqDistance(r, q1_);\n\t\t\tif(d1 < d2) { if(dr < d1) p = r; else p = p1_; }\n\t\t\telse { if(dr < d2) p = r; else p = p2_; }\n\t\t\t\n\t\t\treturn new Segment2D(p, q1_);\n\t\t\t\n\t\t} else {\n\t\t\tif(debug) console.log(\"2 edges\");\n\t\t\tSegment2D q1q2 = new Segment2D(q1_, q2_), p1p2 = new Segment2D(p1_, p2_);\n\t\t\t\n\t\t\tSegment2D[] segs = new Segment2D[8];\n\t\t\tint nseg = 3;\n\t\t\tsegs[0] = new Segment2D(p1_, q1_);\n\t\t\tsegs[1] = new Segment2D(p1_, q2_);\n\t\t\tsegs[2] = new Segment2D(p2_, q1_);\n\t\t\tsegs[3] = new Segment2D(p2_, q2_);\n\t\t\tif(q1q2.projectionIsOnSegment(p1_)) segs[++nseg] = new Segment2D(p1_, q1q2.projection(p1_));\n\t\t\tif(q1q2.projectionIsOnSegment(p2_)) segs[++nseg] = new Segment2D(p2_, q1q2.projection(p2_));\n\t\t\tif(p1p2.projectionIsOnSegment(q1_)) segs[++nseg] = new Segment2D(q1_, p1p2.projection(q1_));\n\t\t\tif(p1p2.projectionIsOnSegment(q2_)) segs[++nseg] = new Segment2D(q2_, p1p2.projection(q2_));\n\n\t\t\tfloat min_d;\n\t\t\tSegment2D min_seg = null;\n\t\t\tfor(int i = 0; i <= nseg; ++i) {\n\t\t\t\tSegment2D seg = segs[i];\n\t\t\t\tfloat d = seg.sqNorm();\n\t\t\t\tif(min_seg == null || d < min_d) { min_d = d; min_seg = seg; }\n\t\t\t}\n\t\t\t\n\t\t\treturn min_seg;\n\t\t}\n\t}\n}\n\nclass Ray2D extends Line2D {\n\tstatic Ray2D fromVector(Point2D o, PVector dir) {\n\t\treturn new Ray2D(o, new Point2D(o.x + dir.x, o.y + dir.y));\n\t}\n\t\n\tRay2D(Point2D na, Point2D nb) {\n\t\tsuper(na, nb);\n\t}\n\t\n\tprotected void draw_() {\t\t\n\t\tnoFill();\n\t\tstroke(strokeColor);\n\n\t\tPoint2D p2 = (a.x < b.x ? pointAtX(width) : pointAtX(0));\n\t\tline(a.x, a.y, p2.x, p2.y);\n\t}\n\t\n\tboolean isUnderMouse() {\n\t\treturn false;\n\t}\n\t\n\tPoint2D lineIntersection(Line2D l) {\n\t\tPoint2D i = super.lineIntersection(l);\n\t\tPVector ia = new PVector(a.x - i.x, a.y - i.y);\n\t\tPVector ba = new PVector(a.x - b.x, a.y - b.y);\n\t\tif(PVector.dot(ia, ba) < 0.0) return null;\n\t\telse return i;\n\t}\n\t\n\tstatic boolean enclosePoints(Ray2D r[], Point2D pt) {\n\t\tPoint2D o = r[0].a;\n\t\tPVector oa = r[0].toPVector();\n\t\tPVector ob = r[1].toPVector();\n\t\tPVector op = new PVector(pt.x - o.x, pt.y - o.y);\n\t\tPVector b = PVector.add(oa, ob);\n\t\t\n\t\tfloat turn1 = PVector.cross(ob, op).z;\n\t\tfloat turn2 = PVector.cross(oa, op).z;\n\t\treturn (turn1*turn2 < 0) && (PVector.dot(op, b) > 0);\n\t}\n}\n\nclass Rectangle2D extends Object2D {\n\tPoint2D origin;\n\tPVector sides;\n\t\n\tRectangle2D(float x, float y, float w, float h) {\n\t\torigin = new Point2D(x, y);\n\t\tsides = new PVector(w, h);\n\t}\n\t\n\tboolean isUnderMouse() {\n\t\tfloat x2 = origin.x + sides.x;\n\t\tfloat y2 = origin.y + sides.y;\n\t\treturn (origin.x <= mouseX) && (x2 >= mouseX) && (origin.y <= mouseY) && (y2 >= mouseY);\n\t}\n\t\n\tPVector center() {\n\t\treturn new PVector(\n\t\t\torigin.position.x + sides.x\/2,\n\t\t\torigin.position.y + sides.y\/2\t\t\n\t\t);\n\t}\n\t\n\tvoid translation(PVector v) {\n\t\torigin.translation(v);\n\t}\n\t\n\tprotected void draw_() {\n\t\tfill(fillColor);\n\t\tstroke(strokeColor);\n\n\t\trect(origin.x, origin.y, sides.x, sides.y);\n\t}\n}\n\nclass Scene {\n\tArrayList objects;\n\tObject2D draggingObject;\n\tPVector dragLastMousePosition;\n\tboolean drawFrame = false;\n\tboolean doUpdate = true;\n\t\n\tScene() {\n\t\tobjects = new ArrayList;\n\t\tnoLoop();\n\t}\n\t\n\tScene add(Object obj) {\n\t\tobjects.add(obj);\n\t\treturn this;\n\t}\n\t\n\tScene addAll(ArrayList objs) {\n\t\tobjects.addAll(objs);\n\t\treturn this;\n\t}\n\t\n\tvoid clear() {\n\t\tobjects = new ArrayList;\n\t\tdraggingObject = null;\n\t}\n\t\n\tvoid draw() {\n\t\tbackground(255);\n\t\tif(doUpdate) for(int i = 0; i < objects.size(); ++i) {\n\t\t\tObject2D updated = objects.get(i).update();\n\t\t\tif(updated != null) objects.set(i, updated);\n\t\t}\n\t\tfor(int i = 0; i < objects.size(); ++i) {\n\t\t\tobjects.get(i).draw();\n\t\t}\n\t\tif(drawFrame) {\n\t\t\tstroke(0); noFill();\n\t\t\trect(0, 0, width - 1, height - 1);\n\t\t}\n\t}\n\t\n\tvoid drag() {\n\t\tif(draggingObject != null && dragLastMousePosition != null) {\n\t\t\tPVector mousePosition = new PVector(mouseX, mouseY);\n\t\t\tPVector offset = PVector.sub(mousePosition, dragLastMousePosition);\n\t\t\tdragLastMousePosition = mousePosition;\n\t\t\tdraggingObject.translation(offset);\n\t\t}\n\t\tredraw();\n\t}\n\t\n\tboolean tick(float dtime) {\n\t\tboolean animation = false;\n\t\tfor(int i = 0; i < objects.size(); ++i) {\n\t\t\tObject2D obj = objects.get(i);\n\t\t\tif(obj.kinetic && obj.velocity != null) {\n\t\t\t\tif(doUpdate) obj.translation(PVector.mult(obj.velocity, dtime));\n\t\t\t\tanimation = true;\n\t\t\t}\n\t\t}\n\t\treturn animation;\n\t}\n\t\n\tObject2D draggableObjectUnderMouse() {\n\t\tfor(int i = 0; i < objects.size(); ++i) {\n\t\t\tObject2D obj = objects.get(i);\n\t\t\tif(obj.draggable && obj.isUnderMouse()) return obj;\n\t\t}\n\t\treturn null;\n\t}\n}\n\n\n\n\nScene scene = new Scene;\nfloat lastTime = 0;\n\nvoid draw() {\n\tfloat time = millis();\n\tfloat dtime = time - lastTime;\n\tlastTime = time;\n\tif(dtime > 500) dtime = 0;\n\t\n\tscene.draw();\n\tboolean animation = scene.tick(dtime);\n\t\n\tif(! animation) noLoop();\n}\n\nvoid mouseMoved() {\n\tObject2D obj = scene.draggableObjectUnderMouse();\n\tif(obj == null) cursor(ARROW);\n\telse cursor(HAND);\n}\n\nvoid mousePressed() {\n\tObject2D obj = scene.draggableObjectUnderMouse();\n\tif(obj == null) {\n\t\tcursor(ARROW);\n\t} else {\n\t\tcursor(HAND);\n\t\tscene.draggingObject = obj;\n\t\tscene.dragLastMousePosition = new PVector(mouseX, mouseY);\n\t}\n}\n\nvoid mouseReleased() {\n\tif(scene.draggingObject) {\n\t\tscene.draggingObject = null;\n\t\tscene.dragLastMousePosition = null;\n\t\tcursor(HAND);\n\t}\n}\n\nvoid mouseDragged() {\n\tscene.drag();\n}\n\nclass Segment2D extends Line2D {\n\tstatic Segment2D fromVector(Point2D o, PVector dir) {\n\t\treturn new Segment2D(o, new Point2D(o.x + dir.x, o.y + dir.y));\n\t}\n\t\n\tSegment2D(Point2D na, Point2D nb) {\n\t\tsuper(na, nb);\n\t}\n\t\n\tprotected void draw_() {\t\t\n\t\tnoFill();\n\t\tstroke(strokeColor);\n\n\t\tline(a.x, a.y, b.x, b.y);\n\t}\n\t\n\tboolean isUnderMouse() {\n\t\treturn super() && projectionIsOnSegment(new Point2D(mouseX, mouseY));\n\t}\n\t\t\n\tfloat norm() {\n\t\treturn sqrt(sqNorm());\n\t}\n\t\n\tfloat sqNorm() {\n\t\treturn sq(a.x - b.x) + sq(a.y - b.y);\n\t}\n\t\n\tPoint2D segmentIntersection(Segment2D seg) {\n\t\tPoint2D i = super.lineIntersection(seg);\n\t\tPVector ia = new PVector(a.x - i.x, a.y - i.y);\n\t\tPVector ib = new PVector(b.x - i.x, b.y - i.y);\n\t\tif(PVector.dot(ia, ib) > 0.0) return null;\n\t\tia = new PVector(seg.a.x - i.x, seg.a.y - i.y);\n\t\tib = new PVector(seg.b.x - i.x, seg.b.y - i.y);\n\t\tif(PVector.dot(ia, ib) > 0.0) return null;\n\t\telse return i;\n\t}\n\t\n\tboolean projectionIsOnSegment(Point2D p) {\n\t\tPVector v = toPVector();\n\t\treturn (PVector.dot(v, Point2D.makePVector(a, p)) > 0 && PVector.dot(v, Point2D.makePVector(b, p)) < 0);\n\t}\n}\n\nint sign(float f) {\n\tif(f > 0.0) return 1;\n\telse if(f < 0.0) return -1;\n\telse return 0;\n}\n\nboolean isUnimodalSequence(ArrayList seq) {\n\tboolean changed = false;\n\tboolean increasing = (seq.get(0) < seq.get(1));\n\tfloat prev = seq.get(1);\n\tfor(int i = 2; i < seq.size(); ++i) {\n\t\tfloat curr = seq.get(i);\n\t\tboolean cmp = (prev < curr);\n\t\tif(cmp != increasing) {\n\t\t\tif(changed) return false;\n\t\t\telse { increasing = cmp; changed = true; }\n\t\t}\n\t\tprev = curr;\n\t}\n\treturn changed;\n}\n\nfloat unimodalSequenceMaximum(ArrayList seq) {\n\t\n}\n\nfloat unimodalSequenceMinimum(ArrayList seq) {\n\t\n}\n\nString formatNumber(float n, int decimals) {\n\tint m = pow(10, decimals);\n\tn *= m;\n\tn = round(n);\n\treturn n \/ m;\n}\n\n";
</script></head>
<body>
	<div class="container">
<div class="navbar navbar-inverse" style="margin-top: 20px">
	<div class="navbar-header">
	  <a class="navbar-brand" href="#">Projet géométrie algorithmique: <strong>Détection de collisions</strong></a>
	</div>
</div>
<div class="navbar navbar-inverse">
	<div class="container">
	  <ul class="nav navbar-nav">
		<li class=""><a href="index.html">Introduction</a></li>
		<li class=""><a href="lp.html">Intersection droite–polygone</a></li>
		<li class=""><a href="pp.html">Intersection polygones</a></li>
		<li class="active"><a href="dmin.html">Distance minimale</a></li>
		<li class=""><a href="ref.html">Références</a></li>
	  </ul>
	</div>
</div>
</div>
	<div class="container">
		<div class="row">
			<div class="col-md-3">
				<ul class="list-group">
					<li class="list-group-item"><a href="#ebin"#>Elimination binaire</a></li>
					<li class="list-group-item"><a href="#iter"#>Phase itérative</a></li>
					<li class="list-group-item"><a href="#final"#>Phase finale</a></li>
					<li class="list-group-item"><a href="#applet"#>Applet</a></li>
				</ul>
			</div>
			<div class="col-md-8">
				<h1>Distance minimale</h1>
				<p>Un problème similaire est de trouver le segment $d$ de longueur minimale qui relie deux polygones convexes $P$ et $Q$. On suppose que ces polygones ne s'intersectent pas. $d$ peut relier les polygones soit en deux points, en un point et un segment, ou en deux segments (parallèles):</p>
				
				<p><img src="media/dpp.svg" width="180px" style="margin-right: 30px"><img src="media/dpl.svg" width="180px" style="margin-right: 30px"><img src="media/dll.svg" width="180px"></p>
				
				<p>Ceci peut être utilisé pour une détection <em>à priori</em> de collisions, puisque $|d|$ approche $0$ avant que les polygones commencent à s'intersecter. L'algorithme suivant permet de trouver $d$ en temps $O(\log n + \log m)$.</p>
				
				<p>D'abord, on calcule les couples de demi-droites $C_1$ et $C_2$ comme au chapitre précédent. Les demi-droites $C_1$ ($C_2$) ont $p_1$ ($q_1$) comme origine et couvrent complètement $Q$ ($P$). On déduit la polyligne $L_p$ de $P$, qui relie les deux points d'intersection $u$ et $t$ de $C_2$ et $P$, tel que $L_p$ est sur le même côte de $ut$ que $Q$. De la même façon, on trouve la polyligne $L_q$ de $Q$. ($L_p$ et $L_q$ ne sont pas liés aux polylignes $L_v$ et $L_w$ du chapitre précédent.) Cette étape peut être fait en temps logarithmique.</p>
				
				<p>Le segment $d$ va relier deux points/segments de $L_p$ et $L_q$. Afin de trouver $d$ en temps logarithmique, on utilise une procédure récursive comme au chapitre précédent, qui élimine à chaque étape une moitié de $L_p$ et/ou $L_q$.</p>
				
				<h2 id="ebin">Algorithme d'élimination binaire</h2>
				<p><img src="media/dmin.svg" align="right" width="330px">On pose $p_*$ et $q_*$ tel que $L_p = \{ p_1, p_2, ..., p_n \}$, et $L_q = \{ q_1, q_2, ..., q_m \}$, tous les deux en sens horlogique. Soit $i = \lfloor \frac{n}{2} \rfloor$ et $j = \lfloor \frac{m}{2} \rfloor$. Soit $m$ le segment qui relie $p_i$ et $q_j$.<br>
				On définit les angles $\alpha', \alpha'', \beta', \beta''$ en sens anti-horlogique, dans $[0, 2\pi[$. Si $m$ pointe dans l'intérieur du polygone, l'angle devient négatif.
				<div class="formula">
					$\alpha' = \angle(p_{i-1}p_{i}, m)$<br>
					$\alpha'' = \angle(m, p_{i}p_{i+1})$<br>
					$\beta' = \angle(m, q_{i}q_{i+1})$<br>
					$\beta'' = \angle(q_{i-1}q_{i}, m)$
				</div>
				Par convexité de $P$ et $Q$, on a:
				<ol>
					<li>$\alpha' + \alpha'' \geq \pi$, et donc $\alpha' \geq \frac{\pi}{2}$ ou $\alpha'' \geq \frac{\pi}{2}$. De même pour $\beta'$ et $\beta''$.</li>
					<li>$\alpha' + \beta' \leq \pi$ implique $\alpha' < \beta''$</li>
					<li>$\alpha' + \beta' > \pi$ ou $\alpha'' + \beta'' > \pi$</li>
				</ol></p>
				
				<h2 id="iter">Phase itérative</h2>
				<p><br clear="right">L'algorithme est répété tant que $|L_p| > 2$ ou $|L_q| > 2$. Pour chaque itération, on distingue les cas suivants:</p>
				
				<p><strong>Cas 1:</strong> $|L_p| = 1$ ($p_i = p_1$).<br>
				Si $\beta' \geq \frac{\pi}{2}$, $L_q \leftarrow \{ q_j, q_{j+1}, ..., q_m \}$. Si $\beta'' \geq \frac{\pi}{2}$, $L_q \leftarrow \{ q_1, ..., q_{j-1}, q_{j} \}$<br>
				Le cas où $|L_q| = 1$ est traité de façon symétrique. Théorème <strong>1</strong> garanti qu'au moins une des deux conditions est toujours vraie. Si $\beta' \geq \frac{\pi}{2}$, alors on $d(p_1, q_j) < d(p_1, q \in q_1...q_j)$. Donc l'opération n'élimine pas de point de $Q$ qui formerait la distance minimale.</p>
				
				<p><strong>Cas 2:</strong> $|L_p| = 2$ ($p_i = p_2$).<br>
				<p></p><img src="media/dmin2.svg" width="280px" style="margin-right: 20px"><img src="media/dmin2_.svg" width="280px"></p>
				<p>Si $\alpha' > 0$, exécuter les étapes suivantes:
				<ol>
					<li>Si $\alpha' + \beta' > \pi$: Si $\alpha' \geq \frac{\pi}{2}, L_p \leftarrow \{ p_2 \}$. Si $\beta' \geq \frac{\pi}{2}, L_q \leftarrow \{ q_j, ... \}$</li>
					<li>Si $\beta'' \geq \frac{\pi}{2}$, $L_q = \{ ..., q_j \}$</li>
					<li>Si $\alpha' < \beta'' < \frac{\pi}{2}$: Si la projection orthogonale de $q_j$ sur le segment $p_{1}p_{2}$ existe: $L_q \leftarrow \{ ..., q_j \}$. Sinon, $L_p \leftarrow \{ p_1 \}$.</li>
				</ol>
				Les étapes <strong>1</strong> et <strong>2</strong> sont justifiés par le même raisonnement qu'au cas 1. Pour l'étape <strong>3</strong>: Si la projection orthogonale $q_{j}'$ existe, alors on a $d(p_{1}p_{2}, q \in q_{1}...q_{j}) > d(q_{j}, q_{j}')$. (Puisque $\beta'' > \alpha'$.) Si le projection n'existe pas, alors $d(p_{1}p_{2}, q) > d(q_{j}, q_{j}')$ pour les mêmes points $q$.</p>
				<p>Si $\alpha' < 0$: $L_p \leftarrow \{ p_1 \}$. De plus, si $\beta' \geq \pi$, $L_q \leftarrow \{ q_j, ... \}$, et si $\beta'' \geq \pi$,  $L_q \leftarrow \{ ..., q_j \}$.</p>
				
				<p><strong>Cas 3:</strong> Les deux polylignes contiennent au moins trois points. On distingue encore deux cas:</p>
				<p>Si tous les 4 angles sont positifs, exécuter les étapes suivantes:
				<ol>
					<li>Si $\alpha' + \beta' > \pi$: Si $\alpha' \geq \frac{\pi}{2}$, $L_q \leftarrow \{ p_i, ... \}$, et si $\beta' > \frac{\pi}{2}$, $L_q \leftarrow \{ q_j, ... \}$.</li>
					<li>Si $\alpha'' + \beta'' > \pi$: Si $\alpha'' \geq \frac{\pi}{2}$, $L_p \leftarrow \{ ..., p_i \}$, et si $\beta'' \geq \frac{\pi}{2}$, $L_q \leftarrow \{ ..., q_j \}$.</li>
				</ol></p>
				<p>Si un angle est négatif (par exemple $\alpha' \leq 0$):<br>
				$L_p \leftarrow \{ ..., p_i \}$. En plus, si $\beta' \geq \pi$, $L_q \leftarrow \{ q_j, ... \}$ et si $\beta'' \geq \pi$, $L_q \leftarrow \{ ..., q_j \}$.</p>
				
				<p>On voit que à chaque étape, $L_q$ et/ou $L_p$ sont réduits à la moitié, ce qui justifie la complexité logarithmique de l'algorithme. A la fin, $L_p$ et $L_q$ contiennent chacun soit un ou deux points. La phase finale va en déduire le segment $d$ (distance minimale des polygones), en temps constant.</p>

				<h2 id="final">Phase finale</h2>
				<p>$|L_p| = 1$ et $|L_q| = 1$, $d = p_{1}q_{1}$.</p>
				
				<p>$|L_p| = 2$ et $|L_q| = 1$: $d$ peut être $p_{1}q_{1}$, $p_{2}q_{1}$, ou bien $q_{1}'q_{1}$, avec $q_{1}'$ la projection orthogonale de $q_{1}$ sur $p{1}p{2}$ (si elle existe). On choisit le segment de longueur minimale. Cas symétrique si $|L_p| = 1$ et $|L_q| = 2$.</p>
				
				<p>$|L_p| = 2$ et $|L_q| = 2$: Similaire au cas 2, on considère tous les segments qui relient les $4$ points, et les $\leq 4$ segments formés par projections orthogonales, et on choisit le segment de longueur minimale.</p>
				
				<h2 id="applet">Applet</h2>
				<p>L'applet suivant implémente l'algorithme décrit.</p>
				<p><canvas id="processing-canvas-1"></canvas><script>
	var js = frameworkJs + "\n\nPolygon2D P, Q;\nSegment2D d;\nPoint2D lvl;\n\nclass Updater extends Object2D {\n\tRay2D[] pencilP_; \/\/ origin in P, encloses Q\n\tRay2D[] pencilQ_; \/\/ origin in Q, encloses P\n\t\n\n\tObject2D update() {\n\t\tpencilP_ = null; pencilQ_ = null;\n\n\t\tboolean convex = true;\t\t\n\t\tif(! P.isConvex()) { P.strokeColor = #FF0000; convex = false; }\n\t\telse P.strokeColor = #000000;\n\t\tif(! Q.isConvex()) { Q.strokeColor = #FF0000; convex = false; }\n\t\telse Q.strokeColor = #000000;\n\t\n\t\tif(! convex) return null;\n\n\t\tpencilP_ = P.pencilOrIntersectionPoint(Q);\n\t\tpencilQ_ = Q.pencilOrIntersectionPoint(P);\n\t\t\n\t\tSegment2D nd = P.minimalDistance(Q);\n\t\tif(nd != null) {\n\t\t\td.visible = true;\n\t\t\td.a = nd.a;\n\t\t\td.b = nd.b;\n\t\t\td.label = \"d = \" + formatNumber(d.norm(), 2);\n\t\t} else {\n\t\t\td.visible = false;\n\t\t}\n\t}\n\t\n\tprivate void drawPencil_(Ray2D[] pencil, color col) {\n\t\tif(pencil == null || pencil[0] == null) return;\n\t\tpencil[0].strokeColor = col;\n\t\tpencil[0].draw();\n\t\tpencil[1].strokeColor = col;\n\t\tpencil[1].draw();\n\t\t\t\t\n\t\tstrokeWeight(3);\n\t\tPoint2D prev = pencil[0].b;\n\t\tfor(Point2D curr = prev.next; prev != pencil[1].b; prev = curr, curr = curr.next) {\n\t\t\tSegment2D seg = new Segment2D(prev, curr);\n\t\t\tseg.draw();\n\t\t}\n\t\tstrokeWeight(1);\n\t}\n\t\n\tprotected void draw_() {\n\t\tdrawPencil_(pencilP_, color(0, 0, 255));\n\t\tdrawPencil_(pencilQ_, color(255, 0, 0));\n\t}\n}\n\nvoid setup() {\n\tP = Polygon2D.generateRandomConvex(7, new PVector(10, 40), new PVector(240, 260));\n\tQ = Polygon2D.generateRandomConvex(15, new PVector(350, 180), new PVector(590, 320));\n\tif(Q.isClockwise()) Q.reversePoints();\n\tif(! P.isClockwise()) P.reversePoints();\n\td = new Segment2D(new Point2D(0, 0), new Point2D(0, 0));\n\tP.label = \"P\"; Q.label = \"Q\";\n\tfor(int i = 0; i < P.points.size(); ++i) P.points.get(i).label = \"p\"+(i+1);\n\tfor(int i = 0; i < Q.points.size(); ++i) Q.points.get(i).label = \"q\"+(i+1);\n\tscene.addAll(P.points).addAll(Q.points).add(P).add(Q).add(d);\n\td.draggable = false; d.strokeColor = #005500;\n\n\tscene.add(new Updater);\t\n\n\tsize(600, 300);\n}\n";
	var procedure = Processing.compile(js);
	var canvas = document.getElementById("processing-canvas-1");
	var instance = new Processing(canvas, procedure);
</script>	</p>
			</div>
		</div>
	</div>
</body>
</html>
