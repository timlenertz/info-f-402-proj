<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>DÃ©tection de collisions</title>
	<link href="media/bootstrap.css" rel="stylesheet">
	<link href="media/style.css" rel="stylesheet">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<script src="media/jquery-2.1.0.min.js"></script>
	<script src="media/flot/jquery.flot.js"></script>
	<script src="media/bootstrap.js"></script>
	<script type="text/x-mathjax-config">
		MathJax.Hub.Config({
			"tex2jax" : { "inlineMath" : [['$','$'], ['\\(','\\)']] },
			"HTML-CSS" : { "scale" : 85 }
		});
	</script>
	<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
	<script src="media/processing.js"></script>
<script 
<script>
	var frameworkJs = "class Line2D extends Object2D {\n\tPoint2D a;\n\tPoint2D b;\n\n\tLine2D(Point2D na, Point2D nb) {\n\t\ta = na;\n\t\tb = nb;\n\t}\n\n\tstatic Line2D fromVector(Point2D o, PVector dir) {\n\t\treturn new Line2D(a, new Point2D(o.x + dir.x, o.y + dir.y));\n\t}\n\t\n\tPVector direction() {\n\t\tPVector dir = toPVector();\n\t\tdir.normalize();\n\t\treturn dir;\n\t}\n\t\n\tPoint2D firstPoint() {\n\t\treturn a;\n\t}\n\t\n\tPoint2D secondPoint() {\n\t\treturn b;\n\t}\n\t\n\tPVector toPVector() {\n\t\treturn new PVector(b.x - a.x, b.y - a.y);\n\t}\n\t\n\tprotected void draw_() {\t\t\n\t\tnoFill();\n\t\tstroke(strokeColor);\n\n\t\tPoint2D p1 = pointAtX(0);\n\t\tPoint2D p2 = pointAtX(width);\n\t\tline(p1.x, p1.y, p2.x, p2.y);\n\t}\n\t\t\n\tvoid translation(PVector v) {\n\t\ta.translation(v);\n\t\tb.translation(v);\n\t}\n\t\n\tPVector center() {\n\t\treturn new PVector(\n\t\t\ta.x + (b.x - a.x)\/2,\n\t\t\ta.y + (b.y - a.y)\/2\n\t\t);\n\t}\n\t\n\tboolean isXAligned() {\n\t\treturn (a.y == b.y);\n\t}\n\t\n\tboolean isYAligned() {\n\t\treturn (a.x == b.x);\n\t}\n\t\n\tfloat slope() {\n\t\tPVector v = toPVector();\n\t\treturn v.y \/ v.x;\n\t}\n\t\n\tfloat offset() {\n\t\treturn a.y - slope()*a.x;\n\t}\n\t\n\tvoid reverse() {\n\t\tPoint2D tmp = a;\n\t\ta = b;\n\t\tb = tmp;\n\t}\n\t\n\tint side(Point2D p) {\n\t\treturn Point2D.turn(a, b, p);\n\t}\n\t\n\tPoint2D pointAtX(float x) {\n\t\tfloat y = slope()*x + offset();\n\t\treturn new Point2D(x, y);\n\t}\n\t\n\tSegment2D orthogonalRejection(Point2D p) {\n\t\tPVector dir = direction();\n\t\tPVector pa = PVector.sub(a.toPVector(), p.toPVector());\n\t\tfloat projectionLength = pa.dot(dir);\n\t\tPVector projection = PVector.mult(dir, projectionLength);\n\t\tPVector rejection = PVector.sub(pa, projection);\n\t\treturn Segment2D.fromVector(p, rejection);\n\t}\n\t\n\tfloat orthogonalDistance(Point2D p) {\n\t\treturn orthogonalRejection(p).norm();\n\t}\n\t\n\tboolean isUnderMouse() {\n\t\tPoint2D m = new Point2D(mouseX, mouseY);\n\t\treturn (orthogonalDistance(m) <= 3)\n\t}\n\t\n\tfloat orientedOrthogonalDistance(Point2D p, Point2D v) {\n\t\tfloat d = orthogonalDistance(p);\n\t\tif(side(p) != side(v)) return -d;\n\t\treturn d;\n\t}\n\t\n\tPoint2D lineIntersection(Line2D l2) {\n\t\tfloat x1 = a.x, y1 = a.y;\n\t\tfloat x2 = b.x, y2 = b.y;\n\t\tfloat x3 = l2.a.x, y3 = l2.a.y;\n\t\tfloat x4 = l2.b.x, y4 = l2.b.y;\n\t\treturn new Point2D(\n\t\t\t  ( (x1*y2 - y1*x2)*(x3 - x4) - (x1 - x2)*(x3*y4 - y3*x4) )\n\t\t\t\/ ( (x1 - x2)*(y3 - y4) - (y1 - y2)*(x3 - x4) ),\n\t\t\t\n\t\t\t  ( (x1*y2 - y1*x2)*(y3 - y4) - (y1 - y2)*(x3*y4 - y3*x4) )\n\t\t\t\/ ( (x1 - x2)*(y3 - y4) - (y1 - y2)*(x3 - x4) )\n\t\t);\n\t}\n\t\n\tPoint2D projection(Point2D p) {\n\t\tPVector ab = toPVector();\n\t\tPVector ap = Point2D.makePVector(a, p);\n\t\tab.normalize();\n\t\tfloat l = PVector.dot(ab, ap);\n\t\tab.mult(l);\n\t\treturn new Point2D(a.x + ab.x, a.y + ab.y);\n\t}\n}\n\nclass Object2D {\n\tboolean visible;\n\tcolor strokeColor;\n\tString label;\n\tboolean draggable;\n\tboolean kinetic;\n\tPVector velocity;\n\t\n\tObject2D() {\n\t\tvelocity = new PVector(0, 0);\n\t\tdraggable = true;\n\t\tkinetic = false;\n\t\tvisible = true;\n\t\tstrokeColor = color(0);\n\t\tlabel = null;\n\t}\n\t\n\tObject2D update() {\n\t\treturn null;\n\t}\n\t\n\tvoid draw() {\n\t\tif(! visible) return;\n\t\tdraw_();\n\t\tif(label != null) {\n\t\t\tfill(strokeColor);\n\t\t\tPVector c = center();\n\t\t\ttextAlign(CENTER);\n\t\t\ttext(label, c.x + 5, c.y + 10);\n\t\t}\n\t}\n\t\n\tprotected void draw_() { }\n\tPVector center() { return null; }\n\tvoid translation(PVector v) { }\n\t\n\tboolean isUnderMouse() { return false; }\n}\n\nclass Point2D extends Object2D {\n\tfloat x;\n\tfloat y;\n\tPoint2D next;\n\tPoint2D previous;\n\t\n\tstatic Point2D fromPVector(PVector v) {\n\t\treturn new Point2D(v.x, v.y);\n\t}\n\t\n\tstatic Point2D makePVector(Point2D a, Point2D b) {\n\t\treturn new PVector(b.x - a.x, b.y - a.y);\n\t}\n\t\n\tPoint2D(float nx, float ny) {\n\t\tx = nx;\n\t\ty = ny;\n\t}\n\t\n\tprotected void draw_() {\t\t\n\t\tnoStroke();\n\t\tfill(strokeColor);\n\n\t\tellipseMode(CENTER);\n\t\tellipse(x, y, 3, 3);\n\t}\n\t\n\tboolean isUnderMouse() {\n\t\tfloat minOffset = 3;\n\t\tfloat dx = abs(x - mouseX);\n\t\tfloat dy = abs(y - mouseY);\n\t\treturn (dx <= minOffset) && (dy <= minOffset);\n\t}\n\t\n\tPVector center() {\n\t\treturn toPVector();\n\t}\n\t\n\tPVector toPVector() {\n\t\treturn new PVector(x, y);\n\t}\n\t\n\tvoid translation(PVector v) {\n\t\tx += v.x;\n\t\ty += v.y;\n\t}\n\t\n\tstatic int turn(Point2D a, Point2D b, Point2D c) {\n\t\tPVector ba = new PVector(a.x - b.x, a.y - b.y);\n\t\tPVector bc = new PVector(c.x - b.x, c.y - b.y);\n\t\tPVector cross = ba.cross(bc);\n\t\treturn sign(cross.z);\n\t}\n\t\n\tstatic float angle(Point2D a, Point2D b, Point2D c) {\n\t\tPVector ba = new PVector(a.x - b.x, a.y - b.y); ba.normalize();\n\t\tPVector bc = new PVector(c.x - b.x, c.y - b.y); bc.normalize();\n\t\tfloat an = acos(PVector.dot(ba, bc));\n\t\tif(PVector.cross(ba, bc).z < 0) return TWO_PI - an;\n\t\telse return an;\n\t}\n\n\tstatic float sqDistance(Point2D a, Point2D b) {\n\t\tfloat x = a.x - b.x;\n\t\tfloat y = a.y - b.y;\n\t\treturn x*x + y*y;\n\t}\n\t\n\tstatic float distance(Point2D a, Point2D b) {\n\t\treturn sqrt(sqDistance(a, b));\n\t}\n\t\n\tstatic void sortPoints(ArrayList pts, int coordinate, boolean ascending) {\n\t\tboolean cont = false;\n\t\tint lim = pts.size();\n\t\tdo {\n\t\t\tfor(int i = 1; i < lim; ++i) {\n\t\t\t\tPoint2D p1 = pts.get(i - 1);\n\t\t\t\tPoint2D p2 = pts.get(i);\n\t\t\t\tboolean swap = false;\n\t\t\t\tif(coordinate == 0) swap = (p1.x > p2.x);\n\t\t\t\telse if(coordinate == 1) swap = (p1.y > p2.y);\n\t\t\t\tif(! ascending) swap = !swap;\n\t\t\t\tif(swap) {\n\t\t\t\t\tcont = true;\n\t\t\t\t\tpts.set(i - 1, p2);\n\t\t\t\t\tpts.set(i, p1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t--lim;\n\t\t} while(cont && lim);\n\t}\n}\n\nclass Polygon2D extends Object2D {\n\tArrayList points;\n\tboolean hasFillColor;\n\tcolor fillColor;\n\t\n\tstatic Polygon2D generateRandom(int nbPoints, PVector low, PVector high) {\n\t\tPolygon2D poly = new Polygon2D;\n\t\tfor(int i = 0; i < nbPoints; ++i) {\n\t\t\tfloat x = random(low.x, high.x);\n\t\t\tfloat y = random(low.y, high.y);\n\t\t\tPoint2D pt = new Point2D(x, y);\n\t\t\tpoly.points.add(pt);\n\t\t}\n\t\tpoly.linkPoints();\n\t\tpoly.randomShiftPoints();\n\t\treturn poly;\n\t}\n\t\n\tstatic Polygon2D generateRandomConvexWithMaximalNumberOfPoints(int nbPoints, PVector low, PVector high) {\n\t\tPolygon2D poly = Polygon2D.generateRandom(nbPoints, low, high);\n\t\tPolygon2D cpoly = poly.convexHull();\n\t\tcpoly.randomShiftPoints();\n\t\treturn cpoly;\n\t}\n\n\tstatic Polygon2D generateRandomConvex(int nbPoints, PVector low, PVector high) {\n\t\tPolygon2D poly = Polygon2D.generateRandomConvexWithMaximalNumberOfPoints(2 * nbPoints, low, high);\n\t\tfloat m = 2;\n\t\twhile(poly.points.size() < nbPoints) {\n\t\t\tm += 0.5;\n\t\t\tpoly = Polygon2D.generateRandomConvexWithMaximalNumberOfPoints(m * nbPoints, low, high);\n\t\t}\n\t\tfor(int remaining = poly.points.size() - nbPoints; remaining > 0; --remaining) {\n\t\t\tint i = floor(random(0, poly.points.size() - 1));\n\t\t\tpoly.points.remove(i);\n\t\t}\n\t\tpoly.linkPoints();\n\t\treturn poly;\n\t}\n\t\n\tPolygon2D() {\n\t\tpoints = new ArrayList();\n\t}\n\t\n\tPolygon2D(ArrayList pts) {\n\t\tpoints = new ArrayList(pts);\n\t\tlinkPoints();\n\t}\n\t\n\tboolean isConvex() {\n\t\tPoint p1 = points.get(points.size() - 2);\n\t\tPoint p2 = points.get(points.size() - 1);\n\t\tPoint p3 = points.get(0);\n\t\tint need_sign = Point2D.turn(p1, p2, p3);\n\t\tfor(int i = 1; i < points.size(); ++i) {\n\t\t\tp1 = p2;\n\t\t\tp2 = p3;\n\t\t\tp3 = points.get(i);\n\t\t\tint sign = Point2D.turn(p1, p2, p3);\n\t\t\tif(sign != need_sign) return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tvoid linkPoints() {\n\t\tfor(int i = 1; i < points.size(); ++i) {\n\t\t\tpoints.get(i - 1).next = points.get(i);\n\t\t\tpoints.get(i).previous = points.get(i - 1);\n\t\t}\n\t\tpoints.get(points.size() - 1).next = points.get(0);\n\t\tpoints.get(0).previous = points.get(points.size() - 1);\n\t}\n\t\n\tPVector center() {\n\t\tPVector c = new PVector(0, 0);\n\t\tfor(int i = 0; i < points.size(); ++i) {\n\t\t\tc.add(points.get(i).toPVector());\n\t\t}\n\t\tc.div(points.size());\n\t\treturn c;\n\t}\n\t\n\tvoid translation(PVector v) {\n\t\tfor(int i = 0; i < points.size(); ++i) {\n\t\t\tpoints.get(i).translation(v);\n\t\t}\n\t}\n\t\n\tprotected void draw_() {\n\t\tif(hasFillColor) fill(fillColor);\n\t\telse noFill();\n\t\tstroke(strokeColor);\n\n\t\tbeginShape();\n\t\tfor(int i = 0; i < points.size(); ++i) {\n\t\t\tPoint2D pt = points.get(i);\n\t\t\tvertex(pt.x, pt.y);\n\t\t}\n\t\tendShape(CLOSE);\n\t}\n\n\t\n\tPolygon2D convexHull() {\n\t\t\/\/ from http:\/\/www.cs.uu.nl\/docs\/vakken\/ga\/slides1.pdf\n\t\tArrayList pts = new ArrayList(points);\n\t\t\n\t\tPoint2D.sortPoints(pts, 0, true);\n\t\t\t\t\n\t\tArrayList upper = new ArrayList();\n\t\tupper.add(pts.get(0)); upper.add(pts.get(1));\n\t\tfor(int i = 2; i < pts.size(); ++i) {\n\t\t\tupper.add(pts.get(i));\n\t\t\tint l = upper.size() - 1;\n\t\t\twhile(upper.size() > 2 && Point2D.turn(upper.get(l-2), upper.get(l-1), upper.get(l)) > 0) {\n\t\t\t\tupper.remove(l-1);\n\t\t\t\tl = upper.size() - 1;\n\t\t\t}\n\t\t}\n\t\t\t\t\t\t\n\t\tPoint2D.sortPoints(pts, 0, false);\n\t\tArrayList lower = new ArrayList();\n\t\tlower.add(pts.get(0)); lower.add(pts.get(1));\n\t\tfor(int i = 2; i < pts.size(); ++i) {\n\t\t\tlower.add(pts.get(i));\n\t\t\tint l = lower.size() - 1;\n\t\t\twhile(lower.size() > 2 && Point2D.turn(lower.get(l-2), lower.get(l-1), lower.get(l)) > 0) {\n\t\t\t\tlower.remove(l-1);\n\t\t\t\tl = lower.size() - 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 1; i < lower.size() - 1; ++i) {\n\t\t\tupper.add(lower.get(i));\n\t\t}\n\t\t\n\t\treturn new Polygon2D(upper);\n\t}\n\t\n\tArrayList segments() {\n\t\tArrayList segments = new ArrayList();\n\t\tfor(int i = 1; i < points.size(); ++i) {\n\t\t\tsegments.add(new Segment2D(points.get(i - 1), points.get(i)));\n\t\t}\n\t\tsegments.add(new Segment2D(points.get(points.size() - 1), points.get(0)));\n\t\treturn segments;\n\t}\n\t\n\tSegment2D segment(int i) {\n\t\ti = i % points.size();\n\t\tif(i < 0) i += points.size();\n\t\tif(i < points.size() - 1) return new Segment2D(points.get(i), points.get(i + 1));\n\t\telse return new Segment2D(points.get(points.size() - 1), points.get(0));\n\t}\n\t\n\tboolean containsPoint(PVector v) {\n\t\tboolean c = false;\n\t\tint j = points.size() - 1;\n\t\tfor(int i = 0; i < points.size(); j = i++) {\n\t\t\tPoint2D pi = points.get(i);\n\t\t\tPoint2D pj = points.get(j);\n\t\t\tif(\n\t\t\t\t((pi.y > v.y) != (pj.y > v.y)) &&\n\t\t\t\t(v.x < (pj.x-pi.x) * (v.y-pi.y) \/ (pj.y-pi.y) + pi.x)\n\t\t\t) c = !c;\n\t\t}\n\t\treturn c;\n\t}\n\t\n\tboolean isUnderMouse() {\n\t\treturn containsPoint(new PVector(mouseX, mouseY));\n\t}\n\t\n\tboolean isClockwise() {\n\t\tfloat sum = 0;\n\t\tArrayList seg = segments();\n\t\tfor(int i = 0; i < seg.size(); ++i) {\n\t\t\tSegment2D s = seg.get(i);\n\t\t\tsum += (s.b.x - s.a.x) * (s.b.y + s.a.y);\n\t\t}\n\t\treturn (sum > 0);\n\t}\n\t\n\tArrayList reversedPoints() {\n\t\tArrayList reversed = new ArrayList;\n\t\tfor(int i = points.size() - 1; i >= 0; --i) {\n\t\t\treversed.add(points.get(i));\n\t\t}\n\t\treturn reversed;\n\t}\n\t\n\tvoid reversePoints() {\n\t\tpoints = reversedPoints();\n\t\tlinkPoints();\n\t}\n\t\n\tvoid shiftPoints(int s) {\n\t\tArrayList newPoints = new ArrayList;\n\t\t\n\t\tfor(int i = 0; i < points.size(); ++i) {\n\t\t\tint j = (i - s) % points.size();\n\t\t\tif(s > i) j += points.size();\n\t\t\tnewPoints.add(points.get(j));\n\t\t}\n\t\tpoints = newPoints;\n\t}\n\t\n\tvoid randomShiftPoints() {\n\t\tshiftPoints(floor(random(1, points.size() - 1)));\n\t}\n\t\n\tfloat pointOrientedDistanceToLine(int i, Line2D line, Point2D v) {\n\t\treturn line.orientedOrthogonalDistance(points.get(i), v);\n\t}\n\t\n\tfloat pointOrientedDistanceToLineG(int i, Line2D line, Point2D v) {\n\t\tfloat f = pointOrientedDistanceToLine(i, line, v);\n\t\tfloat f1 = pointOrientedDistanceToLine(0, line, v);\n\t\tfloat fn = pointOrientedDistanceToLine(points.size() - 1, line, v);\n\t\tfloat t = f1 + (fn - f1)*(i\/(points.size() - 1));\n\t\treturn min(f, t);\n\t}\n\t\n\tfloat segmentPointsOrientedDistancesDifference(int i, Line2D line, Point2D v) {\n\t\tSegment2D seg = segment(i);\n\t\tfloat da = pointOrientedDistanceToLine(i, line, v);\n\t\tfloat db = pointOrientedDistanceToLine((i + 1) % points.size(), line, v);\n\t\treturn db - da;\n\t}\n\t\n\tfloat segmentPointsOrientedDistancesDifferenceG(int i, Line2D line, Point2D v) {\n\t\tSegment2D seg = segment(i);\n\t\tfloat da = pointOrientedDistanceToLineG(i, line, v);\n\t\tfloat db = pointOrientedDistanceToLineG((i + 1) % points.size(), line, v);\n\t\treturn db - da;\n\t}\n\t\n\tfloat lineDistance(Line2D line, Point2D v) {\n\t\tint mn = 0, mx = points.size() - 1;\n\t\twhile(abs(mn - mx) > 1) {\n\t\t\tint i = floor(mn + (mx - mn)\/2);\n\t\t\tfloat dfi = segmentPointsOrientedDistancesDifferenceG(i, line, v);\n\t\t\tif(dfi < 0) mn = i;\n\t\t\telse mx = i;\n\t\t}\n\t\tw = mn + 1;\n\t\treturn pointOrientedDistanceToLine(w, line, v);\n\t}\n\t\n\tint[] lineIntersectionSegmentIndices(Line2D line, Point2D v) {\n\t\tif(v == null) v = points.get(0);\n\t\t\n\t\tfloat f1 = pointOrientedDistanceToLineG(0, line, v);\n\t\tfloat f2 = pointOrientedDistanceToLineG(1, line, v);\n\t\tfloat fn = pointOrientedDistanceToLineG(points.size() - 1, line, v);\n\t\tint w; float fw;\n\t\t\n\t\tint mn = 0, mx = points.size() - 1;\n\t\twhile(abs(mn - mx) > 1) {\n\t\t\tint i = floor(mn + (mx - mn)\/2);\n\t\t\tfloat dfi = segmentPointsOrientedDistancesDifferenceG(i, line, v);\n\t\t\tif(dfi < 0) mn = i;\n\t\t\telse mx = i;\n\t\t}\n\t\tw = mn + 1;\n\t\tfw = pointOrientedDistanceToLine(w, line, v);\n\n\t\tif(fw > 0) {\n\t\t\tint[] inter = {};\n\t\t\treturn inter;\n\t\t} else if(fw == 0) {\n\t\t\tint[] inter = { w };\n\t\t\treturn inter;\n\t\t} else {\n\t\t\tint[] inter = {null, null};\n\n\t\t\tint mn = 0, mx = w;\n\t\t\twhile(abs(mn - mx) > 1) {\n\t\t\t\tint i = floor(mn + (mx - mn)\/2);\n\t\t\t\tfloat fi = pointOrientedDistanceToLine(i, line, v);\n\t\t\t\tif(fi > 0) mn = i;\n\t\t\t\telse mx = i;\n\t\t\t}\n\t\t\tinter[0] = mn;\n\n\t\t\tint mn = w, mx = points.size();\n\t\t\twhile(abs(mn - mx) > 1) {\n\t\t\t\tint i = floor(mn + (mx - mn)\/2);\n\t\t\t\tfloat fi = pointOrientedDistanceToLine(i, line, v);\n\t\t\t\tif(fi < 0) mn = i;\n\t\t\t\telse mx = i;\n\t\t\t}\n\t\t\tinter[1] = mn;\n\t\t\t\n\t\t\treturn inter;\n\t\t}\n\t}\n\t\n\tSegment2D[] lineIntersectionSegments(Line2D l, Point2D v) {\n\t\tint[] segs = lineIntersectionSegmentIndices(l, v);\n\t\tif(segs.length == 0) {\n\t\t\tSegment2D[] segs = {};\n\t\t\treturn segs;\n\t\t} else if(segs.length == 1) {\n\t\t\tSegment2D[] segs = { segment(segs[0]) };\n\t\t\treturn segs;\n\t\t} else if(segs.length == 2) {\n\t\t\tSegment2D[] segs = { segment(segs[0]), segment(segs[1]) };\n\t\t\treturn segs;\n\t\t}\n\t}\n\t\n\tPoint2D[] lineIntersection(Line2D l, Point2D v) {\n\t\tSegment2D[] segs = lineIntersectionSegments(l, v);\n\t\tif(segs.length == 0) {\n\t\t\tPoint2D[] pts = {};\n\t\t\treturn pts;\n\t\t} else if(segs.length == 1) {\n\t\t\tPoint2D[] pts = { segs[0].lineIntersection(l) };\n\t\t\treturn pts;\n\t\t} else if(segs.length == 2) {\n\t\t\tPoint2D[] pts = { segs[0].lineIntersection(l), segs[1].lineIntersection(l) };\n\t\t\treturn pts;\n\t\t}\n\t}\n\t\n\tSegment2D[] rayItersectionSegments(Ray2D r, Point2D v) {\n\t\tSegment2D[] segs = lineIntersectionSegments(r, v);\n\t\tif(segs == null) return null;\n\t\tPoint2D p1 = r.lineIntersection(segs[0]);\n\t\tPoint2D p2 = r.lineIntersection(segs[1]);\n\t\tif(p1 != null && p2 != null) {\n\t\t\treturn segs;\n\t\t} else if(p1 != null) {\n\t\t\tSegment2D[] res = { segs[0] }; return res;\n\t\t} else if(p1 != null) {\n\t\t\tSegment2D[] res = { segs[1] }; return res;\n\t\t}\n\t}\n\t\n\tRay2D[] pencil(Polygon2D Q) {\n\t\tPoint2D qc = Point2D.fromPVector(Q.center());\n\t\tPoint2D p1 = points.get(0);\n\t\tSegment2D[] segs = Q.lineIntersectionSegments(new Line2D(qc, p1));\n\t\tif(segs == null) return null;\n\t\n\t\tPoint2D t, u;\n\t\n\t\tfloat max_a = 0.0;\n\t\tPVector p1qc = new PVector(qc.x - p1.x, qc.y - p1.y);\n\t\tfor(Point2D q = segs[1].b; q != segs[0].a.next; q = q.next) {\n\t\t\tPVector p1q = new PVector(q.x - p1.x, q.y - p1.y);\n\t\t\tfloat a = PVector.angleBetween(p1qc, p1q);\n\t\t\tif(a > max_a) { max_a = a; t = q; }\n\t\t}\n\t\t\n\t\tmax_a = 0.0;\n\t\tfor(Point2D q = segs[0].b; q != segs[1].a.next; q = q.next) {\n\t\t\tPVector p1q = new PVector(q.x - p1.x, q.y - p1.y);\n\t\t\tfloat a = PVector.angleBetween(p1qc, p1q);\n\t\t\tif(a > max_a) { max_a = a; u = q; }\n\t\t}\n\t\t\n\t\tRay2D[] p = {null, null};\n\t\tif(Point2D.turn(t, p1, u) == Point2D.turn(t, t.next, t.next.next)) {\n\t\t\tp[0] = new Ray2D(p1, t); p[1] = new Ray2D(p1, u);\n\t\t} else {\n\t\t\tp[1] = new Ray2D(p1, t); p[0] = new Ray2D(p1, u);\n\t\t}\n\n\t\treturn p;\n\t}\n\t\n\tObject2D[] pencilOrIntersectionPoint(Polygon2D Q) {\n\t\tPoint2D qc = Point2D.fromPVector(Q.center());\n\t\tPoint2D p1 = points.get(0);\n\t\tLine2D l = new Line2D(qc, p1);\n\t\tPoint2D[] ab = Q.lineIntersection(l);\n\t\tPVector p1a = (new Segment2D(p1, ab[0])).toPVector();\n\t\tPVector p1b = (new Segment2D(p1, ab[1])).toPVector();\n\t\tif(PVector.dot(p1a, p1b) < 0) {\n\t\t\tObject2D ret = { null, p1 };\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\treturn pencil(Q);\n\t}\n\t\n\tint indexModulo(int index) {\n\t\tboolean negative = (index < 0);\n\t\tindex %= points.size();\n\t\tif(negative) index += points.size();\n\t\treturn index;\n\t}\n\n\tArrayList pencilOwnPolyline(Ray2D[] pencil) {\n\t\tif(pencil[0].a != pencil[1].a) { console.log(\"rays don't have same origin\"); return null; }\n\t\tPoint2D o = pencil[0].a; \/\/ == pencil.b\n\t\tPoint2D v = o.next; \/\/ must not be o\n\t\tint n = points.size();\n\t\t\n\t\tint first = -1, last = -1;\n\t\tPoint2D firstp = o, lastp = o;\n\t\t\n\t\tint[] inter1 = lineIntersectionSegmentIndices(pencil[0], v);\n\t\t\n\t\tif(inter1.length == 2) {\n\t\t\tif(inter1[0] == 0 || inter1[0] == n) first = inter1[1];\n\t\t\telse first = inter1[0];\n\n\t\t\tfirstp = segment(first).lineIntersection(pencil[0]);\n\t\t\tif(PVector.dot(pencil[0].toPVector(), Point2D.makePVector(o, firstp)) < 0) {\n\t\t\t\tfirstp = o; first = -1;\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tint[] inter2 = lineIntersectionSegmentIndices(pencil[1], v);\n\t\tif(inter2.length == 2) {\n\t\t\tif(inter2[0] == 0 || inter2[0] == n) last = inter2[1];\n\t\t\telse last = inter2[0];\n\n\t\t\tlastp = segment(last).lineIntersection(pencil[1]);\n\t\t\tif(PVector.dot(pencil[1].toPVector(), Point2D.makePVector(o, lastp)) < 0) {\n\t\t\t\tlastp = o; last = -1;\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\tif(first == -1 && last == -1) {\n\t\t\tif(! Ray2D.enclosePoints(pencil, o.next)) return new ArrayList;\t\t\n\t\t} else if(first == -1) {\n\t\t\tif(Ray2D.enclosePoints(pencil, o.next)) first = 0;\n\t\t\telse first = n;\n\t\t} else if(last == -1) {\n\t\t\tif(Ray2D.enclosePoints(pencil, o.next)) last = 0;\n\t\t\telse last = n;\n\t\t}\n\t\t\n\t\tif(first > last) {\n\t\t\tint tmp = first;\n\t\t\tfirst = last;\n\t\t\tlast = tmp;\n\t\t\tPoint2D tmpp = firstp;\n\t\t\tfirstp = lastp;\n\t\t\tlastp = tmpp;\n\t\t}\n\t\t\n\t\tPoint2D secondp = (first == -1 ? o.next : points.get(indexModulo(first + 1)));\n\t\tPoint2D secondlastp = (last == -1 ? o.previous : points.get(indexModulo(last)));\n\n\t\t\n\t\tArrayList pts = new ArrayList;\n\t\tpts.add(firstp);\n\t\tfor(Point2D pt = secondp; pt != secondlastp.next; pt = pt.next) {\n\t\t\tpts.add(pt);\n\t\t}\n\t\tpts.add(lastp);\n\t\t\n\t\treturn pts;\n\t}\n\t\n\tSegment2D minimalDistance(Polygon2D Q) {\n\t\treturn minimalDistanceDebug(Q, 0, false);\n\t}\n\t\n\tSegment2D minimalDistanceDebug(Polygon2D Q, int steps, boolean debug) {\n\t\tPolygon2D P = this;\n\t\t\n\t\tRay2D[] pencilP = P.pencil(Q);\n\t\tRay2D[] pencilQ = Q.pencil(P);\n\t\t\n\t\tArrayList ps = new ArrayList;\n\t\tfor(Point2D p = pencilQ[0].b; p != pencilQ[1].b.next; p = p.next) ps.add(p);\n\n\t\tArrayList qs = new ArrayList;\n\t\tfor(Point2D q = pencilP[0].b; q != pencilP[1].b.next; q = q.next) qs.add(q);\n\n\t\tint p1 = 0, p2 = ps.size() - 1, np = ps.size();\n\t\tint q1 = 0, q2 = qs.size() - 1, nq = qs.size();\n\n\t\tif(debug) {\n\t\t\tfor(int i = points.size() - 1; i >= 0; --i) { points.get(i).strokeColor = #000000; points.get(i).label = i; }\t\n\t\t\tfor(int i = Q.points.size() - 1; i >= 0; --i) { Q.points.get(i).strokeColor = #000000; Q.points.get(i).label = i; }\n\t\t}\n\t\t\n\t\tint currStep = 0;\n\t\twhile(np > 2 || nq > 2) {\n\t\t\tif(++currStep == steps) break;\n\t\t\t\n\t\t\tint oldnp = np, oldnq = nq;\n\t\t\t\n\t\t\tint mpi = p1 + ceil((p2-p1) \/ 2);\n\t\t\tint mqi = q1 + ceil((q2-q1) \/ 2);\n\t\t\tPoint2D mp = ps.get(mpi);\n\t\t\tPoint2D mq = qs.get(mqi);\n\t\t\tif(mp == null || mq == null) return null;\n\t\t\t\t\t\t\n\t\t\tfloat a1 = Point2D.angle(mq, mp, mp.previous);\n\t\t\tfloat a2 = Point2D.angle(mp.next, mp, mq);\n\t\t\tif(a1 > PI && a2 > PI) { a1 -= TWO_PI; a2 -= TWO_PI; }\n\t\t\t\t\n\t\t\tfloat b1 = Point2D.angle(mq.previous, mq, mp);\n\t\t\tfloat b2 = Point2D.angle(mp, mq, mq.next);\n\t\t\tif(b1 > PI && b2 > PI) { b1 -= TWO_PI; b2 -= TWO_PI; }\n\t\t\t\n\t\t\t\/\/\/\/\/\/\/\/\/\/\/\/ DEBUG \/\/\/\/\/\/\/\/\/\/\/\/\n\t\t\tif(debug && currStep == steps-1) {\n\t\t\t\tSegment2D dseg = new Segment2D(mp, mq);\n\t\t\t\tdseg.label = currStep;\n\t\t\t\tdseg.draw();\t\n\t\n\t\t\t\tps.get(p1).strokeColor = #0000ff;\n\t\t\t\tps.get(p1).label = \"P1\";\n\t\t\t\tps.get(p2).strokeColor = #ff0000;\n\t\t\t\tps.get(p2).label = \"P2\";\n\t\t\t\t\n\t\t\t\tqs.get(q1).strokeColor = #0000ff;\n\t\t\t\tqs.get(q1).label = \"Q1\";\n\t\t\t\tqs.get(q2).strokeColor = #ff0000;\n\t\t\t\tqs.get(q2).label = \"Q2\";\n\t\t\t\t\n\t\t\t\tstroke(50);\n\t\t\t\tfloat d = 180.0 \/ PI;\n\t\t\t\ttextAlign(LEFT);\n\t\t\t\ttext(\"a2 = \" + formatNumber(a2*d, 2), mp.x + 5, mp.y - 15);\n\t\t\t\ttext(\"a1 = \" + formatNumber(a1*d, 2), mp.x + 5, mp.y + 15);\n\t\t\t\ttextAlign(RIGHT);\n\t\t\t\ttext(\"b2 = \" + formatNumber(b2*d, 2), mq.x - 5, mq.y - 15);\n\t\t\t\ttext(\"b1 = \" + formatNumber(b1*d, 2), mq.x - 5, mq.y + 15);\n\t\t\t}\n\t\t\t\/\/\/\/\/\/\/\/\/\/\/\/ END DEBUG \/\/\/\/\/\/\/\/\/\/\/\/\n\n\t\t\tif(np == 1) {\n\t\t\t\tif(debug) console.log(\"P: one vertex\");\n\t\t\t\tif(b1 >= HALF_PI) q1 = mqi;\n\t\t\t\tif(b2 >= HALF_PI) q2 = mqi;\n\t\t\t\t\n\t\t\t} else if(nq == 1) {\n\t\t\t\tif(debug) console.log(\"Q: one vertex\");\n\t\t\t\tif(a1 >= HALF_PI) p1 = mpi;\n\t\t\t\tif(a2 >= HALF_PI) p2 = mpi;\n\t\t\t\t\n\t\t\t} else if(np == 2) {\n\t\t\t\tif(debug) console.log(\"P: two vertices\");\n\t\t\t\tif(a1 > 0) {\n\t\t\t\t\tif(a1 + b1 > PI) {\n\t\t\t\t\t\tif(a1 >= HALF_PI) p1 = p2;\n\t\t\t\t\t\tif(b1 >= HALF_PI) q1 = mqi;\n\t\t\t\t\t}\n\t\t\t\t\tif(b2 >= HALF_PI) q2 = mqi;\n\t\t\t\t\tif(a1 < b2 && b2 < HALF_PI) {\n\t\t\t\t\t\tSegment2D p1p2seg = new Segment2D(ps.get(p1), ps.get(p2));\n\t\t\t\t\t\tif(p1p2seg.projectionIsOnSegment(mq)) q2 = mqi;\n\t\t\t\t\t\telse p2 = p1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tp2 = p1;\n\t\t\t\t\tif(b1 >= PI) q1 = mqi;\n\t\t\t\t\tif(b2 >= PI) q2 = mqi;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else if(nq == 2) {\n\t\t\t\tif(debug) console.log(\"Q: two vertices\");\n\t\t\t\tif(b2 > 0) {\n\t\t\t\t\tif(a1 + b1 > PI) {\n\t\t\t\t\t\tif(b1 >= HALF_PI) q1 = q2;\n\t\t\t\t\t\tif(a1 >= HALF_PI) p1 = mpi;\n\t\t\t\t\t}\n\t\t\t\t\tif(a2 >= HALF_PI) p2 = mpi;\n\t\t\t\t\tif(b1 < a2 && a2 < HALF_PI) {\n\t\t\t\t\t\tSegment2D q1q2seg = new Segment2D(qs.get(q1), qs.get(q2));\n\t\t\t\t\t\tif(q1q2seg.projectionIsOnSegment(mp)) p2 = mpi;\n\t\t\t\t\t\telse q2 = q1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tq2 = q1;\n\t\t\t\t\tif(a1 >= PI) p1 = mpi;\n\t\t\t\t\tif(a2 >= PI) p2 = mpi;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else if(a1 >= 0 && a2 >= 0 && b1 >= 0 && b2 >= 0) {\n\t\t\t\tif(debug) console.log(\"> 3 vertices: all angles positive\");\n\t\t\t\tif(a1 + b1 > PI) {\n\t\t\t\t\tif(a1 >= HALF_PI) p1 = mpi;\n\t\t\t\t\tif(b1 >= HALF_PI) q1 = mqi;\n\t\t\t\t}\n\t\t\t\tif(a2 + b2 > PI) {\n\t\t\t\t\tif(a2 >= HALF_PI) p2 = mpi;\n\t\t\t\t\tif(b2 >= HALF_PI) q2 = mqi;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else if(a1 < 0) {\n\t\t\t\tif(debug) console.log(\"> 3 vertices: a1 and a2 negative\");\n\t\t\t\tif(a1 > a2) p2 = mpi;\n\t\t\t\telse p1 = mpi;\n\t\t\t\tif(b1 > PI) q1 = mqi;\n\t\t\t\tif(b2 > PI) q2 = mqi;\n\t\t\t\t\n\n\t\t\t} else if(b1 < 0) {\n\t\t\t\tif(debug) console.log(\"> 3 vertices: b1 and b2 negative\");\n\t\t\t\tif(b1 > b2) q2 = mqi;\n\t\t\t\telse q1 = mqi;\n\t\t\t\tif(a1 > PI) p1 = mpi;\n\t\t\t\tif(a2 > PI) p2 = mpi;\n\t\t\t\t\n\t\t\t}\n\n\t\t\tnp = p2 - p1 + 1;\n\t\t\tnq = q2 - q1 + 1;\n\t\t\t\n\t\t\tif(np >= oldnp && nq >= oldnq) {\n\t\t\t\tif(debug) console.log(\"loop\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t\tif(debug) console.log(oldnp, oldnq, \"->\", np, nq);\n\t\t}\n\t\t\n\t\tif(debug) {\n\t\t\tps.get(p1).label = ps.get(p1).label + \" (P1)\";\n\t\t\tps.get(p2).label = ps.get(p2).label + \" (P2)\";\n\t\t\tqs.get(q1).label = qs.get(q1).label + \" (Q1)\";\n\t\t\tqs.get(q2).label = qs.get(q2).label + \" (Q2)\";\n\t\t}\n\t\t\n\t\tif(np > 2 || nq > 2) return null;\t\t\n\t\t\n\t\tPoint2D p1_ = ps.get(p1), p2_ = ps.get(p2), q1_ = qs.get(q1), q2_ = qs.get(q2);\n\t\tif(p1_ == null || p2_ == null || q1_ == null || q2_ == null) return null;\n\t\t\n\t\tif(np == 1 && nq == 1) {\n\t\t\tif(debug) console.log(\"two vertices\");\n\t\t\treturn new Segment2D(ps.get(p1), qs.get(q1));\n\t\t\t\n\t\t} else if(np == 1) {\n\t\t\tif(debug) console.log(\"edge in Q\");\n\t\t\tPoint2D r, q;\n\t\t\tSegment2D q1q2 = new Segment2D(q1_, q2_);\n\t\t\tif(q1q2.projectionIsOnSegment(p1_)) r = q1q2.projection(p1_); else r = q1_;\n\t\t\t\n\t\t\tfloat d1 = Point2D.sqDistance(q1_, p1_), d2 = Point2D.sqDistance(q2_, p1_), dr = Point2D.sqDistance(r, p1_);\n\t\t\tif(d1 < d2) { if(dr < d1) q = r; else q = q1_; }\n\t\t\telse { if(dr < d2) q = r; else q = q2_; }\n\t\t\t\n\t\t\treturn new Segment2D(p1_, q);\n\t\t\t\n\t\t} else if(nq == 1) {\n\t\t\tif(debug) console.log(\"edge in Q\");\n\t\t\tPoint2D r, p;\n\t\t\tSegment2D p1p2 = new Segment2D(p1_, p2_);\n\t\t\tif(p1p2.projectionIsOnSegment(q1_)) r = p1p2.projection(q1_); else r = p1_;\n\t\t\t\n\t\t\tfloat d1 = Point2D.sqDistance(p1_, q1_), d2 = Point2D.sqDistance(p2_, q1_), dr = Point2D.sqDistance(r, q1_);\n\t\t\tif(d1 < d2) { if(dr < d1) p = r; else p = p1_; }\n\t\t\telse { if(dr < d2) p = r; else p = p2_; }\n\t\t\t\n\t\t\treturn new Segment2D(p, q1_);\n\t\t\t\n\t\t} else {\n\t\t\tif(debug) console.log(\"2 edges\");\n\t\t\tSegment2D q1q2 = new Segment2D(q1_, q2_), p1p2 = new Segment2D(p1_, p2_);\n\t\t\t\n\t\t\tSegment2D[] segs = new Segment2D[8];\n\t\t\tint nseg = 3;\n\t\t\tsegs[0] = new Segment2D(p1_, q1_);\n\t\t\tsegs[1] = new Segment2D(p1_, q2_);\n\t\t\tsegs[2] = new Segment2D(p2_, q1_);\n\t\t\tsegs[3] = new Segment2D(p2_, q2_);\n\t\t\tif(q1q2.projectionIsOnSegment(p1_)) segs[++nseg] = new Segment2D(p1_, q1q2.projection(p1_));\n\t\t\tif(q1q2.projectionIsOnSegment(p2_)) segs[++nseg] = new Segment2D(p2_, q1q2.projection(p2_));\n\t\t\tif(p1p2.projectionIsOnSegment(q1_)) segs[++nseg] = new Segment2D(q1_, p1p2.projection(q1_));\n\t\t\tif(p1p2.projectionIsOnSegment(q2_)) segs[++nseg] = new Segment2D(q2_, p1p2.projection(q2_));\n\n\t\t\tfloat min_d;\n\t\t\tSegment2D min_seg = null;\n\t\t\tfor(int i = 0; i <= nseg; ++i) {\n\t\t\t\tSegment2D seg = segs[i];\n\t\t\t\tfloat d = seg.sqNorm();\n\t\t\t\tif(min_seg == null || d < min_d) { min_d = d; min_seg = seg; }\n\t\t\t}\n\t\t\t\n\t\t\treturn min_seg;\n\t\t}\n\t}\n}\n\nclass Ray2D extends Line2D {\n\tstatic Ray2D fromVector(Point2D o, PVector dir) {\n\t\treturn new Ray2D(o, new Point2D(o.x + dir.x, o.y + dir.y));\n\t}\n\t\n\tRay2D(Point2D na, Point2D nb) {\n\t\tsuper(na, nb);\n\t}\n\t\n\tprotected void draw_() {\t\t\n\t\tnoFill();\n\t\tstroke(strokeColor);\n\n\t\tPoint2D p2 = (a.x < b.x ? pointAtX(width) : pointAtX(0));\n\t\tline(a.x, a.y, p2.x, p2.y);\n\t}\n\t\n\tboolean isUnderMouse() {\n\t\treturn false;\n\t}\n\t\n\tPoint2D lineIntersection(Line2D l) {\n\t\tPoint2D i = super.lineIntersection(l);\n\t\tPVector ia = new PVector(a.x - i.x, a.y - i.y);\n\t\tPVector ba = new PVector(a.x - b.x, a.y - b.y);\n\t\tif(PVector.dot(ia, ba) < 0.0) return null;\n\t\telse return i;\n\t}\n\t\n\tstatic boolean enclosePoints(Ray2D r[], Point2D pt) {\n\t\tPoint2D o = r[0].a;\n\t\tPVector oa = r[0].toPVector();\n\t\tPVector ob = r[1].toPVector();\n\t\tPVector op = new PVector(pt.x - o.x, pt.y - o.y);\n\t\tPVector b = PVector.add(oa, ob);\n\t\t\n\t\tfloat turn1 = PVector.cross(ob, op).z;\n\t\tfloat turn2 = PVector.cross(oa, op).z;\n\t\treturn (turn1*turn2 < 0) && (PVector.dot(op, b) > 0);\n\t}\n}\n\nclass Rectangle2D extends Object2D {\n\tPoint2D origin;\n\tPVector sides;\n\t\n\tRectangle2D(float x, float y, float w, float h) {\n\t\torigin = new Point2D(x, y);\n\t\tsides = new PVector(w, h);\n\t}\n\t\n\tboolean isUnderMouse() {\n\t\tfloat x2 = origin.x + sides.x;\n\t\tfloat y2 = origin.y + sides.y;\n\t\treturn (origin.x <= mouseX) && (x2 >= mouseX) && (origin.y <= mouseY) && (y2 >= mouseY);\n\t}\n\t\n\tPVector center() {\n\t\treturn new PVector(\n\t\t\torigin.position.x + sides.x\/2,\n\t\t\torigin.position.y + sides.y\/2\t\t\n\t\t);\n\t}\n\t\n\tvoid translation(PVector v) {\n\t\torigin.translation(v);\n\t}\n\t\n\tprotected void draw_() {\n\t\tfill(fillColor);\n\t\tstroke(strokeColor);\n\n\t\trect(origin.x, origin.y, sides.x, sides.y);\n\t}\n}\n\nclass Scene {\n\tArrayList objects;\n\tObject2D draggingObject;\n\tPVector dragLastMousePosition;\n\tboolean drawFrame = false;\n\tboolean doUpdate = true;\n\t\n\tScene() {\n\t\tobjects = new ArrayList;\n\t\tnoLoop();\n\t}\n\t\n\tScene add(Object obj) {\n\t\tobjects.add(obj);\n\t\treturn this;\n\t}\n\t\n\tScene addAll(ArrayList objs) {\n\t\tobjects.addAll(objs);\n\t\treturn this;\n\t}\n\t\n\tvoid clear() {\n\t\tobjects = new ArrayList;\n\t\tdraggingObject = null;\n\t}\n\t\n\tvoid draw() {\n\t\tbackground(255);\n\t\tif(doUpdate) for(int i = 0; i < objects.size(); ++i) {\n\t\t\tObject2D updated = objects.get(i).update();\n\t\t\tif(updated != null) objects.set(i, updated);\n\t\t}\n\t\tfor(int i = 0; i < objects.size(); ++i) {\n\t\t\tobjects.get(i).draw();\n\t\t}\n\t\tif(drawFrame) {\n\t\t\tstroke(0); noFill();\n\t\t\trect(0, 0, width - 1, height - 1);\n\t\t}\n\t}\n\t\n\tvoid drag() {\n\t\tif(draggingObject != null && dragLastMousePosition != null) {\n\t\t\tPVector mousePosition = new PVector(mouseX, mouseY);\n\t\t\tPVector offset = PVector.sub(mousePosition, dragLastMousePosition);\n\t\t\tdragLastMousePosition = mousePosition;\n\t\t\tdraggingObject.translation(offset);\n\t\t}\n\t\tredraw();\n\t}\n\t\n\tboolean tick(float dtime) {\n\t\tboolean animation = false;\n\t\tfor(int i = 0; i < objects.size(); ++i) {\n\t\t\tObject2D obj = objects.get(i);\n\t\t\tif(obj.kinetic && obj.velocity != null) {\n\t\t\t\tif(doUpdate) obj.translation(PVector.mult(obj.velocity, dtime));\n\t\t\t\tanimation = true;\n\t\t\t}\n\t\t}\n\t\treturn animation;\n\t}\n\t\n\tObject2D draggableObjectUnderMouse() {\n\t\tfor(int i = 0; i < objects.size(); ++i) {\n\t\t\tObject2D obj = objects.get(i);\n\t\t\tif(obj.draggable && obj.isUnderMouse()) return obj;\n\t\t}\n\t\treturn null;\n\t}\n}\n\n\n\n\nScene scene = new Scene;\nfloat lastTime = 0;\n\nvoid draw() {\n\tfloat time = millis();\n\tfloat dtime = time - lastTime;\n\tlastTime = time;\n\tif(dtime > 500) dtime = 0;\n\t\n\tscene.draw();\n\tboolean animation = scene.tick(dtime);\n\t\n\tif(! animation) noLoop();\n}\n\nvoid mouseMoved() {\n\tObject2D obj = scene.draggableObjectUnderMouse();\n\tif(obj == null) cursor(ARROW);\n\telse cursor(HAND);\n}\n\nvoid mousePressed() {\n\tObject2D obj = scene.draggableObjectUnderMouse();\n\tif(obj == null) {\n\t\tcursor(ARROW);\n\t} else {\n\t\tcursor(HAND);\n\t\tscene.draggingObject = obj;\n\t\tscene.dragLastMousePosition = new PVector(mouseX, mouseY);\n\t}\n}\n\nvoid mouseReleased() {\n\tif(scene.draggingObject) {\n\t\tscene.draggingObject = null;\n\t\tscene.dragLastMousePosition = null;\n\t\tcursor(HAND);\n\t}\n}\n\nvoid mouseDragged() {\n\tscene.drag();\n}\n\nclass Segment2D extends Line2D {\n\tstatic Segment2D fromVector(Point2D o, PVector dir) {\n\t\treturn new Segment2D(o, new Point2D(o.x + dir.x, o.y + dir.y));\n\t}\n\t\n\tSegment2D(Point2D na, Point2D nb) {\n\t\tsuper(na, nb);\n\t}\n\t\n\tprotected void draw_() {\t\t\n\t\tnoFill();\n\t\tstroke(strokeColor);\n\n\t\tline(a.x, a.y, b.x, b.y);\n\t}\n\t\n\tboolean isUnderMouse() {\n\t\treturn super() && projectionIsOnSegment(new Point2D(mouseX, mouseY));\n\t}\n\t\t\n\tfloat norm() {\n\t\treturn sqrt(sqNorm());\n\t}\n\t\n\tfloat sqNorm() {\n\t\treturn sq(a.x - b.x) + sq(a.y - b.y);\n\t}\n\t\n\tPoint2D segmentIntersection(Segment2D seg) {\n\t\tPoint2D i = super.lineIntersection(seg);\n\t\tPVector ia = new PVector(a.x - i.x, a.y - i.y);\n\t\tPVector ib = new PVector(b.x - i.x, b.y - i.y);\n\t\tif(PVector.dot(ia, ib) > 0.0) return null;\n\t\tia = new PVector(seg.a.x - i.x, seg.a.y - i.y);\n\t\tib = new PVector(seg.b.x - i.x, seg.b.y - i.y);\n\t\tif(PVector.dot(ia, ib) > 0.0) return null;\n\t\telse return i;\n\t}\n\t\n\tboolean projectionIsOnSegment(Point2D p) {\n\t\tPVector v = toPVector();\n\t\treturn (PVector.dot(v, Point2D.makePVector(a, p)) > 0 && PVector.dot(v, Point2D.makePVector(b, p)) < 0);\n\t}\n}\n\nint sign(float f) {\n\tif(f > 0.0) return 1;\n\telse if(f < 0.0) return -1;\n\telse return 0;\n}\n\nboolean isUnimodalSequence(ArrayList seq) {\n\tboolean changed = false;\n\tboolean increasing = (seq.get(0) < seq.get(1));\n\tfloat prev = seq.get(1);\n\tfor(int i = 2; i < seq.size(); ++i) {\n\t\tfloat curr = seq.get(i);\n\t\tboolean cmp = (prev < curr);\n\t\tif(cmp != increasing) {\n\t\t\tif(changed) return false;\n\t\t\telse { increasing = cmp; changed = true; }\n\t\t}\n\t\tprev = curr;\n\t}\n\treturn changed;\n}\n\nfloat unimodalSequenceMaximum(ArrayList seq) {\n\t\n}\n\nfloat unimodalSequenceMinimum(ArrayList seq) {\n\t\n}\n\nString formatNumber(float n, int decimals) {\n\tint m = pow(10, decimals);\n\tn *= m;\n\tn = round(n);\n\treturn n \/ m;\n}\n\n";
</script></head>
<body>
	<div class="container">
<div class="navbar navbar-inverse" style="margin-top: 20px">
	<div class="navbar-header">
	  <a class="navbar-brand" href="#">Projet gÃ©omÃ©trie algorithmique: <strong>DÃ©tection de collisions</strong></a>
	</div>
</div>
<div class="navbar navbar-inverse">
	<div class="container">
	  <ul class="nav navbar-nav">
		<li class=""><a href="index.html">Introduction</a></li>
		<li class="active"><a href="lp.html">Intersection droiteâpolygone</a></li>
		<li class=""><a href="pp.html">Intersection polygones</a></li>
		<li class=""><a href="dmin.html">Distance minimale</a></li>
		<li class=""><a href="ref.html">RÃ©fÃ©rences</a></li>
	  </ul>
	</div>
</div>
</div>
	<div class="container">
		<div class="row">
			<div class="col-md-3">
				<ul class="list-group">
					<li class="list-group-item"><a href="#unibimod"#>Unimodale / bimodale</a></li>
					<li class="list-group-item"><a href="#dior"#>Distances orientÃ©es</a></li>
					<li class="list-group-item"><a href="#dior"#>Algorithme IGL</a></li>
					<li class="list-group-item"><a href="#applet"#>Applet</a></li>
				</ul>
			</div>
			<div class="col-md-8">
				<h1>Intersection droiteâpolygone convexe</h1>
				<h2 id="unibimod">Fonctions unimodales et bimodales</h2>
				<p>Une fonction $f : \{1, 2, .., n\} \rightarrow \mathbb{R}$ est <em>unimodale</em>, s'il existe un entier $m \in [1, n]$ tel que $f$ est strictement croissante (ou dÃ©croissante) en $[1, m]$, et strictement dÃ©croissante (ou croissante) en $[m + 1, n]$. Les deux extrÃ©ma de la fonction peuvent Ãªtre trouvÃ©s en temps logarithmique:</p>
				
				<p>En comparant $f(1)$ et $f(2)$, on peut dÃ©terminer si la premiÃ¨re partie de $j$ est croissante ou dÃ©croissante. Au premier cas, $\min \{ f(1), f(n-1) \}$ est le minimum de $f$, et au deuxiÃ¨me cas, $\max \{ f(1), f(n-1) \}$ est le maximum. L'autre extremum $m$ de $f$ peut Ãªtre trouvÃ© par recherche dichotomique, en considÃ©rant sa fonction dÃ©rivÃ©e $f'(i) = f(i + 1) - f(i)$, qui est strictement positive en $[1, m[$ et strictement nÃ©gative en $[m, n[$.</p>
				
				<p>Une fonction $f$ est <em>bimodale</em>, s'il existe un entier $r \in [1, n]$ tel que la sÃ©quence $f(r), f(r+1), ..., f(n), f(1), f(2), ..., f(r-1)$ est unimodale. En autre mots, une fonction est bimodale si elle peut Ãªtre transformÃ©e en une fonction unimodale en appliquant un dÃ©calage circulaire modulo $n$ aux indices. Elle est donc composÃ©e de trois parties ($\nearrow \searrow \nearrow$ ou $\searrow \nearrow \searrow$) sur lesquelles elle est strictement monotone, et elle a deux points d'inflexion. En plus, pour la premiÃ¨re forme, on a $f(1) < f(n)$, et pour la deuxiÃ¨me, $f(1) > f(n)$. Il est possible de trouver les extÃ©ma d'une fonction bimodale aussi en temps logarithmique: Soit $T$ la fonction de la droite qui rejoint $(1, f(1))$ et $(n, f(n))$
				<div class="formula">
					$T(x) = f(1) + \frac{x-1}{n-1}(f(n) - f(1))$
				</div>
				On distingue deux cas:
				<ul>
					<li>$f(1) \leq f(n)$: Si $f(2) \geq f(1)$, $f(1)$ est le minimum, et le maximum se trouve dans $f(2)...f(n)$, qui est unimodal. Si $f(2) < f(1)$, on dÃ©fine la fonction $g(x) = \min \{ f(x), T(x) \}$. On a $\forall x, g(x) \leq f(n)$. Donc le maximum de $g$ ne peut pas Ãªtre plus grand que $g(n)$, et donc $g$ est unimodal, et son minimum correspond Ã  celui de $f$. AprÃ¨s avoir trouvÃ© ce minimum $x$, le maximum peut Ãªtre trouvÃ© dans la sÃ©quence unimodale $f(x+1)...f(n)$.</li>
					<li>$f(1) \geq f(n)$: Situation inverse; Si $f(2) \leq f(1)$, $f(1)$ est le maximum, et le minimum de trouve dans $f(2)...f(n)$. Sinon, le minimum $x$ est celui de $g$, et le maximum est dans $f(0)...f(x-1)$.</li>
				</ul>
				
	
				<h2 id="dior">BimodalitÃ© des distances orientÃ©s</h2>
				<p>Soit $\{ p_1, p_2, ..., p_{n} \}$ les points de $P$ en ordre horlogique. Soit $d(x, L)$ la distance orthogonale entre un point $x$ et la droite $L$. La <em>distance orientÃ©e</em> $h(x, L, v)$ par rapport au point $v$ est dÃ©finie comme $d(x, L)$ si $x$ et $v$ se trouvent sur le mÃªme cÃ´tÃ© de $L$, et $-d(x, L)$ au cas contraire. Alors on peut montrer que $\forall v \notin L$, la fonction $f(i) = h(p_{i}, L, v)$ est bimodale:</p>
				
				<p><img src="media/hBimodal.svg" align="right" width="300px">Soit $p_k$ le point pour lequel $f$ est minimal. ($p_7$ sur le graphique) Pour que $f$ soit bimodale, il suffit de montrer que la sÃ©quence $f(k), f(k + 1), ..., f(k - 1)$ (indices modulo $n$) est unimodale.<br>
				Soit $r$ le verteur directeur de $L$, orientÃ© tel que $\angle(r, p_{k}p_{k+1}) < \pi$. Tous les angles sont prises en sens anti-horlogigue, dans $[0, 2\pi[$. Soit $a_i = \angle(r, p_{i}p_{i+1})$ et $b_i = \angle(p_{i}p_{i+1}, p_{i-1}p_{i})$. Les relations suivantes sont vrai pour tout $i$:
				<div class="formula">
					$f(i + 1) = f(i) + |p_{i}p_{i+1}| \sin a_i$<br>
					$a_{i+1} = a_i - b_{i+1}$
				</div>
				Comme $P$ est convexe, tous $\forall i, b_i < \pi$. En plus $\sum b_i = 2\pi$. Par consÃ©quent, la sÃ©quence $\sin a_k, \sin a_{k+1}, ..., \sin a_{k-1}$ est positive, puis nÃ©gative. Donc $f(k), f(k + 1), ..., f(k - 1)$ est unimodale, et $f$ est bimodale.</p>
				
				<br clear="right">
				<h2 id="igl">Algorithme <em>IGL</em></h2><a href="igl"></a>
				<p>On peut trouver les points d'intersection entre $L$ et $P$ en cherchant les extrÃ©ma de $f$, et donc en temps $O(\log n)$. On suppose d'abord que $p_1 \notin L$. Ceci ne nuit pas Ã  la gÃ©nÃ©ralitÃ©, car on peut dÃ©caler les indices des points sinon. On a que $f(i) = h(p_i, L, p_1)$ est bimodale, et on peut trouver le point $p_w$ pour lequel $f(w)$ est minimal en temps logarithmique. $P$ et $L$ ne s'intersectent seulement si $f(w) \leq 0$:</p>
				
				<p>Si $f(w) > 0$, tous les points de $P$ se trouveraient sur le mÃªme cÃ´tÃ© $L$ (car tous les points sont du mÃªme cÃ´tÃ© de $L$ que $p_1$), et il n'y a donc pas de point d'intersection. Si $f(w) = 0$, le point $p_w$ se trouve sur $L$ et est le point d'intersection unique: Tous les autres points sont plus Ã©loignÃ©s de $L$ et sont sur un mÃªme cÃ´tÃ©. Ces deux conditions sont suffisantes et nÃ©cessaires.</p>
				
				<p>Il reste le cas $f(w) < 0$, pour lequel il y a deux points d'intersection, sur deux segments $(p_i, p_{i+1})$ du polygone. Pour ces deux segments, leurs deux points se trouvent sur les cÃ´tÃ©s opposÃ©s de $L$ (c.Ã .d. $f(i) \times f(i+1) < 0$). Comme on sait que $w$ est le minimum de la fonction unimodale $f$, on peut trouver les deux segments par recherche dichotomique sur les sÃ©quences $f(w), f(w+1), ..., f(n)$, et $f(1), f(2), ...., f(w)$ respectivement. Le point d'intersection de $L$ et du segment peut ensuite Ãªtre dÃ©terminÃ© en temps constant.</p>
				
				<h2 id="applet">Applet</h2>
				<p>Le programme suivant calcule les points d'intersection et $L$ et $P$. Les objets peuvent Ãªtre dÃ©placÃ©s avec la souris. Le graphe montre la fonction $f(i)$ (bimodale) en bleu, ainsi que $g(i)$ (unimodale) en vert, quand elle est diffÃ©rente. Le programme utilise la mÃ©thode dÃ©crite pour trouver les points d'intersection.</p>
								<canvas id="processing-canvas-1" style="display: inline-block"></canvas>
				<div id="linePolygonIntersectionPlot" style="display: inline-block"></div>
				<script>
				document.linePolygonIntersectionPlot = $.plot("#linePolygonIntersectionPlot", [], {
					"yaxis" : { "min" : -300, "max" : 300, "ticks" : 1, "tickFormatter" : function() { return ''; } },
					"xaxis" : { "tickDecimals" : 0, "tickSize" : 1, "tickFormatter" : function(i) { return i + 1; } },
					"series" : { "lines" : { "show" : true }, "points" : { "show" : false }, "shadowSize" : 0 },
					"colors" : [ "green", "blue" ]
				});
				</script>
				<script>
	var js = frameworkJs + "\n\nPolygon2D polygon;\nLine2D L;\nPoint2D i1, i2;\n\nclass Updater extends Object2D {\t\n\tObject2D update() {\n\t\ti1.visible = false;\n\t\ti2.visible = false;\n\n\t\tif(! polygon.isConvex()) { polygon.strokeColor = #ff0000; return; }\n\t\telse polygon.strokeColor = #000000;\n\t\t\n\t\tint n = polygon.points.size();\n\t\tObject[] f = new float[n], g = new float[n];\n\t\tfor(int i = 0; i < n; ++i) {\n\t\t\tf[i] = {i, polygon.pointOrientedDistanceToLine(i, L, polygon.points.get(0))};\n\t\t\tg[i] = {i, polygon.pointOrientedDistanceToLineG(i, L, polygon.points.get(0))};\n\t\t}\n\n\t\tdocument.linePolygonIntersectionPlot.setData([g, f]);\n\t\tdocument.linePolygonIntersectionPlot.setupGrid();\n\t\tdocument.linePolygonIntersectionPlot.draw();\n\t\t\n\t\tPoint2D[] intersection = polygon.lineIntersection(L);\n\t\tif(intersection.length == 1) {\n\t\t\ti1.visible = true;\n\t\t\ti1.x = intersection[0].x;\n\t\t\ti1.y = intersection[0].y;\n\t\t} else if(intersection.length == 2) {\n\t\t\ti1.visible = true;\n\t\t\ti1.x = intersection[0].x;\n\t\t\ti1.y = intersection[0].y;\n\t\t\ti2.visible = true;\n\t\t\ti2.x = intersection[1].x;\n\t\t\ti2.y = intersection[1].y;\t\t\t\n\t\t}\n\t}\n}\n\nvoid setup() {\n\tpolygon = Polygon2D.generateRandomConvex(12, new PVector(10, 40), new PVector(140, 260));\n\tL = new Line2D(new Point2D(100, 80), new Point2D(140, 230));\n\tL.strokeColor = #0000ff; L.label = \"L\";\n\ti1 = new Point2D(0, 0);\n\ti2 = new Point2D(0, 0);\n\ti1.strokeColor = #ff0000; i1.label = \"I1\"; i1.visible = true; i1.draggable = false;\n\ti2.strokeColor = #ff0000; i2.label = \"I2\"; i2.visible = true; i2.draggable = false;\n\tline.label = \"L\";\n\tpolygon.label = \"P\";\n\tfor(int i = 0; i < polygon.points.size(); ++i) polygon.points.get(i).label = \"p\"+(i+1);\n\t\n\tpolygon.points.get(0).strokeColor = #0000ff;\n\tscene.add(L.a).add(L.b).add(L).addAll(polygon.points).add(polygon).add(i1).add(i2);\n\tscene.add(new Updater);\n\t\t\t\n\tsize(300, 300);\n}\n";
	var procedure = Processing.compile(js);
	var canvas = document.getElementById("processing-canvas-1");
	var instance = new Processing(canvas, procedure);
</script>	<
			</div>
		</div>
	</div>
</body>
</html>
