<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>DÃ©tection de collisions</title>
	<link href="media/bootstrap.css" rel="stylesheet">
	<link href="media/style.css" rel="stylesheet">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<script src="media/jquery-2.1.0.min.js"></script>
	<script src="media/bootstrap.js"></script>
	<script type="text/x-mathjax-config">
		MathJax.Hub.Config({
			"tex2jax" : { "inlineMath" : [['$','$'], ['\\(','\\)']] },
			"HTML-CSS" : { "scale" : 85 }
		});
	</script>
	<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
	<script src="media/processing.js"></script>
<script 
<script>
	var frameworkJs = "class Line2D extends Object2D {\n\tPoint2D a;\n\tPoint2D b;\n\n\tLine2D(Point2D na, Point2D nb) {\n\t\ta = na;\n\t\tb = nb;\n\t}\n\n\tstatic Line2D fromVector(Point2D o, PVector dir) {\n\t\treturn new Line2D(a, new Point2D(o.x + dir.x, o.y + dir.y));\n\t}\n\t\n\tPVector direction() {\n\t\tPVector dir = toPVector();\n\t\tdir.normalize();\n\t\treturn dir;\n\t}\n\t\n\tPoint2D firstPoint() {\n\t\treturn a;\n\t}\n\t\n\tPoint2D secondPoint() {\n\t\treturn b;\n\t}\n\t\n\tPVector toPVector() {\n\t\treturn new PVector(b.x - a.x, b.y - a.y);\n\t}\n\t\n\tprotected void draw_() {\t\t\n\t\tnoFill();\n\t\tstroke(strokeColor);\n\n\t\tPoint2D p1 = pointAtX(0);\n\t\tPoint2D p2 = pointAtX(width);\n\t\tline(p1.x, p1.y, p2.x, p2.y);\n\t}\n\t\t\n\tvoid translation(PVector v) {\n\t\ta.translation(v);\n\t\tb.translation(v);\n\t}\n\t\n\tPVector center() {\n\t\treturn new PVector(\n\t\t\ta.x + (b.x - a.x)\/2,\n\t\t\ta.y + (b.y - a.y)\/2\n\t\t);\n\t}\n\t\n\tboolean isXAligned() {\n\t\treturn (a.y == b.y);\n\t}\n\t\n\tboolean isYAligned() {\n\t\treturn (a.x == b.x);\n\t}\n\t\n\tfloat slope() {\n\t\tPVector v = toPVector();\n\t\treturn v.y \/ v.x;\n\t}\n\t\n\tfloat offset() {\n\t\treturn a.y - slope()*a.x;\n\t}\n\t\n\tvoid reverse() {\n\t\tPoint2D tmp = a;\n\t\ta = b;\n\t\tb = tmp;\n\t}\n\t\n\tint side(Point2D p) {\n\t\treturn Point2D.turn(a, b, p);\n\t}\n\t\n\tPoint2D pointAtX(float x) {\n\t\tfloat y = slope()*x + offset();\n\t\treturn new Point2D(x, y);\n\t}\n\t\n\tSegment2D orthogonalRejection(Point2D p) {\n\t\tPVector dir = direction();\n\t\tPVector pa = PVector.sub(a.toPVector(), p.toPVector());\n\t\tfloat projectionLength = pa.dot(dir);\n\t\tPVector projection = PVector.mult(dir, projectionLength);\n\t\tPVector rejection = PVector.sub(pa, projection);\n\t\treturn Segment2D.fromVector(p, rejection);\n\t}\n\t\n\tfloat orthogonalDistance(Point2D p) {\n\t\treturn orthogonalRejection(p).norm();\n\t}\n\t\n\tboolean isUnderMouse() {\n\t\tPoint2D m = new Point2D(mouseX, mouseY);\n\t\treturn (orthogonalDistance(m) <= 3)\n\t}\n\t\n\tfloat orientedOrthogonalDistance(Point2D p, Point2D v) {\n\t\tfloat d = orthogonalDistance(p);\n\t\tif(side(p) != side(v)) return -d;\n\t\treturn d;\n\t}\n\t\n\tPoint2D lineIntersection(Line2D l2) {\n\t\tfloat x1 = a.x, y1 = a.y;\n\t\tfloat x2 = b.x, y2 = b.y;\n\t\tfloat x3 = l2.a.x, y3 = l2.a.y;\n\t\tfloat x4 = l2.b.x, y4 = l2.b.y;\n\t\treturn new Point2D(\n\t\t\t  ( (x1*y2 - y1*x2)*(x3 - x4) - (x1 - x2)*(x3*y4 - y3*x4) )\n\t\t\t\/ ( (x1 - x2)*(y3 - y4) - (y1 - y2)*(x3 - x4) ),\n\t\t\t\n\t\t\t  ( (x1*y2 - y1*x2)*(y3 - y4) - (y1 - y2)*(x3*y4 - y3*x4) )\n\t\t\t\/ ( (x1 - x2)*(y3 - y4) - (y1 - y2)*(x3 - x4) )\n\t\t);\n\t}\n\t\n\tPoint2D projection(Point2D p) {\n\t\tPVector ab = toPVector();\n\t\tPVector ap = Point2D.makePVector(a, p);\n\t\tab.normalize();\n\t\tfloat l = PVector.dot(ab, ap);\n\t\tab.mult(l);\n\t\treturn new Point2D(a.x + ab.x, a.y + ab.y);\n\t}\n}\n\nclass Object2D {\n\tboolean visible;\n\tcolor strokeColor;\n\tString label;\n\tboolean draggable;\n\tboolean kinetic;\n\tPVector velocity;\n\t\n\tObject2D() {\n\t\tvelocity = new PVector(0, 0);\n\t\tdraggable = true;\n\t\tkinetic = false;\n\t\tvisible = true;\n\t\tstrokeColor = color(0);\n\t\tlabel = null;\n\t}\n\t\n\tObject2D update() {\n\t\treturn null;\n\t}\n\t\n\tvoid draw() {\n\t\tif(! visible) return;\n\t\tdraw_();\n\t\tif(label != null) {\n\t\t\tfill(strokeColor);\n\t\t\tPVector c = center();\n\t\t\ttextAlign(CENTER);\n\t\t\ttext(label, c.x + 5, c.y + 10);\n\t\t}\n\t}\n\t\n\tprotected void draw_() { }\n\tPVector center() { return null; }\n\tvoid translation(PVector v) { }\n\t\n\tboolean isUnderMouse() { return false; }\n}\n\nclass Point2D extends Object2D {\n\tfloat x;\n\tfloat y;\n\tPoint2D next;\n\tPoint2D previous;\n\t\n\tstatic Point2D fromPVector(PVector v) {\n\t\treturn new Point2D(v.x, v.y);\n\t}\n\t\n\tstatic Point2D makePVector(Point2D a, Point2D b) {\n\t\treturn new PVector(b.x - a.x, b.y - a.y);\n\t}\n\t\n\tPoint2D(float nx, float ny) {\n\t\tx = nx;\n\t\ty = ny;\n\t}\n\t\n\tprotected void draw_() {\t\t\n\t\tnoStroke();\n\t\tfill(strokeColor);\n\n\t\tellipseMode(CENTER);\n\t\tellipse(x, y, 3, 3);\n\t}\n\t\n\tboolean isUnderMouse() {\n\t\tfloat minOffset = 3;\n\t\tfloat dx = abs(x - mouseX);\n\t\tfloat dy = abs(y - mouseY);\n\t\treturn (dx <= minOffset) && (dy <= minOffset);\n\t}\n\t\n\tPVector center() {\n\t\treturn toPVector();\n\t}\n\t\n\tPVector toPVector() {\n\t\treturn new PVector(x, y);\n\t}\n\t\n\tvoid translation(PVector v) {\n\t\tx += v.x;\n\t\ty += v.y;\n\t}\n\t\n\tstatic int turn(Point2D a, Point2D b, Point2D c) {\n\t\tPVector ba = new PVector(a.x - b.x, a.y - b.y);\n\t\tPVector bc = new PVector(c.x - b.x, c.y - b.y);\n\t\tPVector cross = ba.cross(bc);\n\t\treturn sign(cross.z);\n\t}\n\t\n\tstatic float angle(Point2D a, Point2D b, Point2D c) {\n\t\tPVector ba = new PVector(a.x - b.x, a.y - b.y); ba.normalize();\n\t\tPVector bc = new PVector(c.x - b.x, c.y - b.y); bc.normalize();\n\t\tfloat an = acos(PVector.dot(ba, bc));\n\t\tif(PVector.cross(ba, bc).z < 0) return TWO_PI - an;\n\t\telse return an;\n\t}\n\n\tstatic float sqDistance(Point2D a, Point2D b) {\n\t\tfloat x = a.x - b.x;\n\t\tfloat y = a.y - b.y;\n\t\treturn x*x + y*y;\n\t}\n\t\n\tstatic float distance(Point2D a, Point2D b) {\n\t\treturn sqrt(sqDistance(a, b));\n\t}\n\t\n\tstatic void sortPoints(ArrayList pts, int coordinate, boolean ascending) {\n\t\tboolean cont = false;\n\t\tint lim = pts.size();\n\t\tdo {\n\t\t\tfor(int i = 1; i < lim; ++i) {\n\t\t\t\tPoint2D p1 = pts.get(i - 1);\n\t\t\t\tPoint2D p2 = pts.get(i);\n\t\t\t\tboolean swap = false;\n\t\t\t\tif(coordinate == 0) swap = (p1.x > p2.x);\n\t\t\t\telse if(coordinate == 1) swap = (p1.y > p2.y);\n\t\t\t\tif(! ascending) swap = !swap;\n\t\t\t\tif(swap) {\n\t\t\t\t\tcont = true;\n\t\t\t\t\tpts.set(i - 1, p2);\n\t\t\t\t\tpts.set(i, p1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t--lim;\n\t\t} while(cont && lim);\n\t}\n}\n\nclass Polygon2D extends Object2D {\n\tArrayList points;\n\tboolean hasFillColor;\n\tcolor fillColor;\n\t\n\tstatic Polygon2D generateRandom(int nbPoints, PVector low, PVector high) {\n\t\tPolygon2D poly = new Polygon2D;\n\t\tfor(int i = 0; i < nbPoints; ++i) {\n\t\t\tfloat x = random(low.x, high.x);\n\t\t\tfloat y = random(low.y, high.y);\n\t\t\tPoint2D pt = new Point2D(x, y);\n\t\t\tpoly.points.add(pt);\n\t\t}\n\t\tpoly.linkPoints();\n\t\tpoly.randomShiftPoints();\n\t\treturn poly;\n\t}\n\t\n\tstatic Polygon2D generateRandomConvexWithMaximalNumberOfPoints(int nbPoints, PVector low, PVector high) {\n\t\tPolygon2D poly = Polygon2D.generateRandom(nbPoints, low, high);\n\t\tPolygon2D cpoly = poly.convexHull();\n\t\tcpoly.randomShiftPoints();\n\t\treturn cpoly;\n\t}\n\n\tstatic Polygon2D generateRandomConvex(int nbPoints, PVector low, PVector high) {\n\t\tPolygon2D poly = Polygon2D.generateRandomConvexWithMaximalNumberOfPoints(2 * nbPoints, low, high);\n\t\tfloat m = 2;\n\t\twhile(poly.points.size() < nbPoints) {\n\t\t\tm += 0.5;\n\t\t\tpoly = Polygon2D.generateRandomConvexWithMaximalNumberOfPoints(m * nbPoints, low, high);\n\t\t}\n\t\tfor(int remaining = poly.points.size() - nbPoints; remaining > 0; --remaining) {\n\t\t\tint i = floor(random(0, poly.points.size() - 1));\n\t\t\tpoly.points.remove(i);\n\t\t}\n\t\tpoly.linkPoints();\n\t\treturn poly;\n\t}\n\t\n\tPolygon2D() {\n\t\tpoints = new ArrayList();\n\t}\n\t\n\tPolygon2D(ArrayList pts) {\n\t\tpoints = new ArrayList(pts);\n\t\tlinkPoints();\n\t}\n\t\n\tboolean isConvex() {\n\t\tPoint p1 = points.get(points.size() - 2);\n\t\tPoint p2 = points.get(points.size() - 1);\n\t\tPoint p3 = points.get(0);\n\t\tint need_sign = Point2D.turn(p1, p2, p3);\n\t\tfor(int i = 1; i < points.size(); ++i) {\n\t\t\tp1 = p2;\n\t\t\tp2 = p3;\n\t\t\tp3 = points.get(i);\n\t\t\tint sign = Point2D.turn(p1, p2, p3);\n\t\t\tif(sign != need_sign) return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tvoid linkPoints() {\n\t\tfor(int i = 1; i < points.size(); ++i) {\n\t\t\tpoints.get(i - 1).next = points.get(i);\n\t\t\tpoints.get(i).previous = points.get(i - 1);\n\t\t}\n\t\tpoints.get(points.size() - 1).next = points.get(0);\n\t\tpoints.get(0).previous = points.get(points.size() - 1);\n\t}\n\t\n\tPVector center() {\n\t\tPVector c = new PVector(0, 0);\n\t\tfor(int i = 0; i < points.size(); ++i) {\n\t\t\tc.add(points.get(i).toPVector());\n\t\t}\n\t\tc.div(points.size());\n\t\treturn c;\n\t}\n\t\n\tvoid translation(PVector v) {\n\t\tfor(int i = 0; i < points.size(); ++i) {\n\t\t\tpoints.get(i).translation(v);\n\t\t}\n\t}\n\t\n\tprotected void draw_() {\n\t\tif(hasFillColor) fill(fillColor);\n\t\telse noFill();\n\t\tstroke(strokeColor);\n\n\t\tbeginShape();\n\t\tfor(int i = 0; i < points.size(); ++i) {\n\t\t\tPoint2D pt = points.get(i);\n\t\t\tvertex(pt.x, pt.y);\n\t\t}\n\t\tendShape(CLOSE);\n\t}\n\n\t\n\tPolygon2D convexHull() {\n\t\t\/\/ from http:\/\/www.cs.uu.nl\/docs\/vakken\/ga\/slides1.pdf\n\t\tArrayList pts = new ArrayList(points);\n\t\t\n\t\tPoint2D.sortPoints(pts, 0, true);\n\t\t\t\t\n\t\tArrayList upper = new ArrayList();\n\t\tupper.add(pts.get(0)); upper.add(pts.get(1));\n\t\tfor(int i = 2; i < pts.size(); ++i) {\n\t\t\tupper.add(pts.get(i));\n\t\t\tint l = upper.size() - 1;\n\t\t\twhile(upper.size() > 2 && Point2D.turn(upper.get(l-2), upper.get(l-1), upper.get(l)) > 0) {\n\t\t\t\tupper.remove(l-1);\n\t\t\t\tl = upper.size() - 1;\n\t\t\t}\n\t\t}\n\t\t\t\t\t\t\n\t\tPoint2D.sortPoints(pts, 0, false);\n\t\tArrayList lower = new ArrayList();\n\t\tlower.add(pts.get(0)); lower.add(pts.get(1));\n\t\tfor(int i = 2; i < pts.size(); ++i) {\n\t\t\tlower.add(pts.get(i));\n\t\t\tint l = lower.size() - 1;\n\t\t\twhile(lower.size() > 2 && Point2D.turn(lower.get(l-2), lower.get(l-1), lower.get(l)) > 0) {\n\t\t\t\tlower.remove(l-1);\n\t\t\t\tl = lower.size() - 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 1; i < lower.size() - 1; ++i) {\n\t\t\tupper.add(lower.get(i));\n\t\t}\n\t\t\n\t\treturn new Polygon2D(upper);\n\t}\n\t\n\tArrayList segments() {\n\t\tArrayList segments = new ArrayList();\n\t\tfor(int i = 1; i < points.size(); ++i) {\n\t\t\tsegments.add(new Segment2D(points.get(i - 1), points.get(i)));\n\t\t}\n\t\tsegments.add(new Segment2D(points.get(points.size() - 1), points.get(0)));\n\t\treturn segments;\n\t}\n\t\n\tSegment2D segment(int i) {\n\t\ti = i % points.size();\n\t\tif(i < 0) i += points.size();\n\t\tif(i < points.size() - 1) return new Segment2D(points.get(i), points.get(i + 1));\n\t\telse return new Segment2D(points.get(points.size() - 1), points.get(0));\n\t}\n\t\n\tboolean containsPoint(PVector v) {\n\t\tboolean c = false;\n\t\tint j = points.size() - 1;\n\t\tfor(int i = 0; i < points.size(); j = i++) {\n\t\t\tPoint2D pi = points.get(i);\n\t\t\tPoint2D pj = points.get(j);\n\t\t\tif(\n\t\t\t\t((pi.y > v.y) != (pj.y > v.y)) &&\n\t\t\t\t(v.x < (pj.x-pi.x) * (v.y-pi.y) \/ (pj.y-pi.y) + pi.x)\n\t\t\t) c = !c;\n\t\t}\n\t\treturn c;\n\t}\n\t\n\tboolean isUnderMouse() {\n\t\treturn containsPoint(new PVector(mouseX, mouseY));\n\t}\n\t\n\tboolean isClockwise() {\n\t\tfloat sum = 0;\n\t\tArrayList seg = segments();\n\t\tfor(int i = 0; i < seg.size(); ++i) {\n\t\t\tSegment2D s = seg.get(i);\n\t\t\tsum += (s.b.x - s.a.x) * (s.b.y + s.a.y);\n\t\t}\n\t\treturn (sum > 0);\n\t}\n\t\n\tArrayList reversedPoints() {\n\t\tArrayList reversed = new ArrayList;\n\t\tfor(int i = points.size() - 1; i >= 0; --i) {\n\t\t\treversed.add(points.get(i));\n\t\t}\n\t\treturn reversed;\n\t}\n\t\n\tvoid reversePoints() {\n\t\tpoints = reversedPoints();\n\t\tlinkPoints();\n\t}\n\t\n\tvoid shiftPoints(int s) {\n\t\tArrayList newPoints = new ArrayList;\n\t\t\n\t\tfor(int i = 0; i < points.size(); ++i) {\n\t\t\tint j = (i - s) % points.size();\n\t\t\tif(s > i) j += points.size();\n\t\t\tnewPoints.add(points.get(j));\n\t\t}\n\t\tpoints = newPoints;\n\t}\n\t\n\tvoid randomShiftPoints() {\n\t\tshiftPoints(floor(random(1, points.size() - 1)));\n\t}\n\t\n\tfloat pointOrientedDistanceToLine(int i, Line2D line, Point2D v) {\n\t\treturn line.orientedOrthogonalDistance(points.get(i), v);\n\t}\n\t\n\tfloat pointOrientedDistanceToLineG(int i, Line2D line, Point2D v) {\n\t\tfloat f = pointOrientedDistanceToLine(i, line, v);\n\t\tfloat f1 = pointOrientedDistanceToLine(0, line, v);\n\t\tfloat fn = pointOrientedDistanceToLine(points.size() - 1, line, v);\n\t\tfloat t = f1 + (fn - f1)*(i\/(points.size() - 1));\n\t\treturn min(f, t);\n\t}\n\t\n\tfloat segmentPointsOrientedDistancesDifference(int i, Line2D line, Point2D v) {\n\t\tSegment2D seg = segment(i);\n\t\tfloat da = pointOrientedDistanceToLine(i, line, v);\n\t\tfloat db = pointOrientedDistanceToLine((i + 1) % points.size(), line, v);\n\t\treturn db - da;\n\t}\n\t\n\tfloat segmentPointsOrientedDistancesDifferenceG(int i, Line2D line, Point2D v) {\n\t\tSegment2D seg = segment(i);\n\t\tfloat da = pointOrientedDistanceToLineG(i, line, v);\n\t\tfloat db = pointOrientedDistanceToLineG((i + 1) % points.size(), line, v);\n\t\treturn db - da;\n\t}\n\t\n\tfloat lineDistance(Line2D line, Point2D v) {\n\t\tint mn = 0, mx = points.size() - 1;\n\t\twhile(abs(mn - mx) > 1) {\n\t\t\tint i = floor(mn + (mx - mn)\/2);\n\t\t\tfloat dfi = segmentPointsOrientedDistancesDifferenceG(i, line, v);\n\t\t\tif(dfi < 0) mn = i;\n\t\t\telse mx = i;\n\t\t}\n\t\tw = mn + 1;\n\t\treturn pointOrientedDistanceToLine(w, line, v);\n\t}\n\t\n\tint[] lineIntersectionSegmentIndices(Line2D line, Point2D v) {\n\t\tif(v == null) v = points.get(0);\n\t\t\n\t\tfloat f1 = pointOrientedDistanceToLineG(0, line, v);\n\t\tfloat f2 = pointOrientedDistanceToLineG(1, line, v);\n\t\tfloat fn = pointOrientedDistanceToLineG(points.size() - 1, line, v);\n\t\tint w; float fw;\n\t\t\n\t\tint mn = 0, mx = points.size() - 1;\n\t\twhile(abs(mn - mx) > 1) {\n\t\t\tint i = floor(mn + (mx - mn)\/2);\n\t\t\tfloat dfi = segmentPointsOrientedDistancesDifferenceG(i, line, v);\n\t\t\tif(dfi < 0) mn = i;\n\t\t\telse mx = i;\n\t\t}\n\t\tw = mn + 1;\n\t\tfw = pointOrientedDistanceToLine(w, line, v);\n\n\t\tif(fw > 0) {\n\t\t\tint[] inter = {};\n\t\t\treturn inter;\n\t\t} else if(fw == 0) {\n\t\t\tint[] inter = { w };\n\t\t\treturn inter;\n\t\t} else {\n\t\t\tint[] inter = {null, null};\n\n\t\t\tint mn = 0, mx = w;\n\t\t\twhile(abs(mn - mx) > 1) {\n\t\t\t\tint i = floor(mn + (mx - mn)\/2);\n\t\t\t\tfloat fi = pointOrientedDistanceToLine(i, line, v);\n\t\t\t\tif(fi > 0) mn = i;\n\t\t\t\telse mx = i;\n\t\t\t}\n\t\t\tinter[0] = mn;\n\n\t\t\tint mn = w, mx = points.size();\n\t\t\twhile(abs(mn - mx) > 1) {\n\t\t\t\tint i = floor(mn + (mx - mn)\/2);\n\t\t\t\tfloat fi = pointOrientedDistanceToLine(i, line, v);\n\t\t\t\tif(fi < 0) mn = i;\n\t\t\t\telse mx = i;\n\t\t\t}\n\t\t\tinter[1] = mn;\n\t\t\t\n\t\t\treturn inter;\n\t\t}\n\t}\n\t\n\tSegment2D[] lineIntersectionSegments(Line2D l, Point2D v) {\n\t\tint[] segs = lineIntersectionSegmentIndices(l, v);\n\t\tif(segs.length == 0) {\n\t\t\tSegment2D[] segs = {};\n\t\t\treturn segs;\n\t\t} else if(segs.length == 1) {\n\t\t\tSegment2D[] segs = { segment(segs[0]) };\n\t\t\treturn segs;\n\t\t} else if(segs.length == 2) {\n\t\t\tSegment2D[] segs = { segment(segs[0]), segment(segs[1]) };\n\t\t\treturn segs;\n\t\t}\n\t}\n\t\n\tPoint2D[] lineIntersection(Line2D l, Point2D v) {\n\t\tSegment2D[] segs = lineIntersectionSegments(l, v);\n\t\tif(segs.length == 0) {\n\t\t\tPoint2D[] pts = {};\n\t\t\treturn pts;\n\t\t} else if(segs.length == 1) {\n\t\t\tPoint2D[] pts = { segs[0].lineIntersection(l) };\n\t\t\treturn pts;\n\t\t} else if(segs.length == 2) {\n\t\t\tPoint2D[] pts = { segs[0].lineIntersection(l), segs[1].lineIntersection(l) };\n\t\t\treturn pts;\n\t\t}\n\t}\n\t\n\tSegment2D[] rayItersectionSegments(Ray2D r, Point2D v) {\n\t\tSegment2D[] segs = lineIntersectionSegments(r, v);\n\t\tif(segs == null) return null;\n\t\tPoint2D p1 = r.lineIntersection(segs[0]);\n\t\tPoint2D p2 = r.lineIntersection(segs[1]);\n\t\tif(p1 != null && p2 != null) {\n\t\t\treturn segs;\n\t\t} else if(p1 != null) {\n\t\t\tSegment2D[] res = { segs[0] }; return res;\n\t\t} else if(p1 != null) {\n\t\t\tSegment2D[] res = { segs[1] }; return res;\n\t\t}\n\t}\n\t\n\tRay2D[] pencil(Polygon2D Q) {\n\t\tPoint2D qc = Point2D.fromPVector(Q.center());\n\t\tPoint2D p1 = points.get(0);\n\t\tSegment2D[] segs = Q.lineIntersectionSegments(new Line2D(qc, p1));\n\t\tif(segs == null) return null;\n\t\n\t\tPoint2D t, u;\n\t\n\t\tfloat max_a = 0.0;\n\t\tPVector p1qc = new PVector(qc.x - p1.x, qc.y - p1.y);\n\t\tfor(Point2D q = segs[1].b; q != segs[0].a.next; q = q.next) {\n\t\t\tPVector p1q = new PVector(q.x - p1.x, q.y - p1.y);\n\t\t\tfloat a = PVector.angleBetween(p1qc, p1q);\n\t\t\tif(a > max_a) { max_a = a; t = q; }\n\t\t}\n\t\t\n\t\tmax_a = 0.0;\n\t\tfor(Point2D q = segs[0].b; q != segs[1].a.next; q = q.next) {\n\t\t\tPVector p1q = new PVector(q.x - p1.x, q.y - p1.y);\n\t\t\tfloat a = PVector.angleBetween(p1qc, p1q);\n\t\t\tif(a > max_a) { max_a = a; u = q; }\n\t\t}\n\t\t\n\t\tRay2D[] p = {null, null};\n\t\tif(Point2D.turn(t, p1, u) == Point2D.turn(t, t.next, t.next.next)) {\n\t\t\tp[0] = new Ray2D(p1, t); p[1] = new Ray2D(p1, u);\n\t\t} else {\n\t\t\tp[1] = new Ray2D(p1, t); p[0] = new Ray2D(p1, u);\n\t\t}\n\n\t\treturn p;\n\t}\n\t\n\tObject2D[] pencilOrIntersectionPoint(Polygon2D Q) {\n\t\tPoint2D qc = Point2D.fromPVector(Q.center());\n\t\tPoint2D p1 = points.get(0);\n\t\tLine2D l = new Line2D(qc, p1);\n\t\tPoint2D[] ab = Q.lineIntersection(l);\n\t\tPVector p1a = (new Segment2D(p1, ab[0])).toPVector();\n\t\tPVector p1b = (new Segment2D(p1, ab[1])).toPVector();\n\t\tif(PVector.dot(p1a, p1b) < 0) {\n\t\t\tObject2D ret = { null, p1 };\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\treturn pencil(Q);\n\t}\n\t\n\tint indexModulo(int index) {\n\t\tboolean negative = (index < 0);\n\t\tindex %= points.size();\n\t\tif(negative) index += points.size();\n\t\treturn index;\n\t}\n\n\tArrayList pencilOwnPolyline(Ray2D[] pencil) {\n\t\tif(pencil[0].a != pencil[1].a) { console.log(\"rays don't have same origin\"); return null; }\n\t\tPoint2D o = pencil[0].a; \/\/ == pencil.b\n\t\tPoint2D v = o.next; \/\/ must not be o\n\t\tint n = points.size();\n\t\t\n\t\tint first = -1, last = -1;\n\t\tPoint2D firstp = o, lastp = o;\n\t\t\n\t\tint[] inter1 = lineIntersectionSegmentIndices(pencil[0], v);\n\t\t\n\t\tif(inter1.length == 2) {\n\t\t\tif(inter1[0] == 0 || inter1[0] == n) first = inter1[1];\n\t\t\telse first = inter1[0];\n\n\t\t\tfirstp = segment(first).lineIntersection(pencil[0]);\n\t\t\tif(PVector.dot(pencil[0].toPVector(), Point2D.makePVector(o, firstp)) < 0) {\n\t\t\t\tfirstp = o; first = -1;\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tint[] inter2 = lineIntersectionSegmentIndices(pencil[1], v);\n\t\tif(inter2.length == 2) {\n\t\t\tif(inter2[0] == 0 || inter2[0] == n) last = inter2[1];\n\t\t\telse last = inter2[0];\n\n\t\t\tlastp = segment(last).lineIntersection(pencil[1]);\n\t\t\tif(PVector.dot(pencil[1].toPVector(), Point2D.makePVector(o, lastp)) < 0) {\n\t\t\t\tlastp = o; last = -1;\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\tif(first == -1 && last == -1) {\n\t\t\tif(! Ray2D.enclosePoints(pencil, o.next)) return new ArrayList;\t\t\n\t\t} else if(first == -1) {\n\t\t\tif(Ray2D.enclosePoints(pencil, o.next)) first = 0;\n\t\t\telse first = n;\n\t\t} else if(last == -1) {\n\t\t\tif(Ray2D.enclosePoints(pencil, o.next)) last = 0;\n\t\t\telse last = n;\n\t\t}\n\t\t\n\t\tif(first > last) {\n\t\t\tint tmp = first;\n\t\t\tfirst = last;\n\t\t\tlast = tmp;\n\t\t\tPoint2D tmpp = firstp;\n\t\t\tfirstp = lastp;\n\t\t\tlastp = tmpp;\n\t\t}\n\t\t\n\t\tPoint2D secondp = (first == -1 ? o.next : points.get(indexModulo(first + 1)));\n\t\tPoint2D secondlastp = (last == -1 ? o.previous : points.get(indexModulo(last)));\n\n\t\t\n\t\tArrayList pts = new ArrayList;\n\t\tpts.add(firstp);\n\t\tfor(Point2D pt = secondp; pt != secondlastp.next; pt = pt.next) {\n\t\t\tpts.add(pt);\n\t\t}\n\t\tpts.add(lastp);\n\t\t\n\t\treturn pts;\n\t}\n\t\n\tSegment2D minimalDistance(Polygon2D Q) {\n\t\treturn minimalDistanceDebug(Q, 0, false);\n\t}\n\t\n\tSegment2D minimalDistanceDebug(Polygon2D Q, int steps, boolean debug) {\n\t\tPolygon2D P = this;\n\t\t\n\t\tRay2D[] pencilP = P.pencil(Q);\n\t\tRay2D[] pencilQ = Q.pencil(P);\n\t\t\n\t\tArrayList ps = new ArrayList;\n\t\tfor(Point2D p = pencilQ[0].b; p != pencilQ[1].b.next; p = p.next) ps.add(p);\n\n\t\tArrayList qs = new ArrayList;\n\t\tfor(Point2D q = pencilP[0].b; q != pencilP[1].b.next; q = q.next) qs.add(q);\n\n\t\tint p1 = 0, p2 = ps.size() - 1, np = ps.size();\n\t\tint q1 = 0, q2 = qs.size() - 1, nq = qs.size();\n\n\t\tif(debug) {\n\t\t\tfor(int i = points.size() - 1; i >= 0; --i) { points.get(i).strokeColor = #000000; points.get(i).label = i; }\t\n\t\t\tfor(int i = Q.points.size() - 1; i >= 0; --i) { Q.points.get(i).strokeColor = #000000; Q.points.get(i).label = i; }\n\t\t}\n\t\t\n\t\tint currStep = 0;\n\t\twhile(np > 2 || nq > 2) {\n\t\t\tif(++currStep == steps) break;\n\t\t\t\n\t\t\tint oldnp = np, oldnq = nq;\n\t\t\t\n\t\t\tint mpi = p1 + ceil((p2-p1) \/ 2);\n\t\t\tint mqi = q1 + ceil((q2-q1) \/ 2);\n\t\t\tPoint2D mp = ps.get(mpi);\n\t\t\tPoint2D mq = qs.get(mqi);\n\t\t\tif(mp == null || mq == null) return null;\n\t\t\t\t\t\t\n\t\t\tfloat a1 = Point2D.angle(mq, mp, mp.previous);\n\t\t\tfloat a2 = Point2D.angle(mp.next, mp, mq);\n\t\t\tif(a1 > PI && a2 > PI) { a1 -= TWO_PI; a2 -= TWO_PI; }\n\t\t\t\t\n\t\t\tfloat b1 = Point2D.angle(mq.previous, mq, mp);\n\t\t\tfloat b2 = Point2D.angle(mp, mq, mq.next);\n\t\t\tif(b1 > PI && b2 > PI) { b1 -= TWO_PI; b2 -= TWO_PI; }\n\t\t\t\n\t\t\t\/\/\/\/\/\/\/\/\/\/\/\/ DEBUG \/\/\/\/\/\/\/\/\/\/\/\/\n\t\t\tif(debug && currStep == steps-1) {\n\t\t\t\tSegment2D dseg = new Segment2D(mp, mq);\n\t\t\t\tdseg.label = currStep;\n\t\t\t\tdseg.draw();\t\n\t\n\t\t\t\tps.get(p1).strokeColor = #0000ff;\n\t\t\t\tps.get(p1).label = \"P1\";\n\t\t\t\tps.get(p2).strokeColor = #ff0000;\n\t\t\t\tps.get(p2).label = \"P2\";\n\t\t\t\t\n\t\t\t\tqs.get(q1).strokeColor = #0000ff;\n\t\t\t\tqs.get(q1).label = \"Q1\";\n\t\t\t\tqs.get(q2).strokeColor = #ff0000;\n\t\t\t\tqs.get(q2).label = \"Q2\";\n\t\t\t\t\n\t\t\t\tstroke(50);\n\t\t\t\tfloat d = 180.0 \/ PI;\n\t\t\t\ttextAlign(LEFT);\n\t\t\t\ttext(\"a2 = \" + formatNumber(a2*d, 2), mp.x + 5, mp.y - 15);\n\t\t\t\ttext(\"a1 = \" + formatNumber(a1*d, 2), mp.x + 5, mp.y + 15);\n\t\t\t\ttextAlign(RIGHT);\n\t\t\t\ttext(\"b2 = \" + formatNumber(b2*d, 2), mq.x - 5, mq.y - 15);\n\t\t\t\ttext(\"b1 = \" + formatNumber(b1*d, 2), mq.x - 5, mq.y + 15);\n\t\t\t}\n\t\t\t\/\/\/\/\/\/\/\/\/\/\/\/ END DEBUG \/\/\/\/\/\/\/\/\/\/\/\/\n\n\t\t\tif(np == 1) {\n\t\t\t\tif(debug) console.log(\"P: one vertex\");\n\t\t\t\tif(b1 >= HALF_PI) q1 = mqi;\n\t\t\t\tif(b2 >= HALF_PI) q2 = mqi;\n\t\t\t\t\n\t\t\t} else if(nq == 1) {\n\t\t\t\tif(debug) console.log(\"Q: one vertex\");\n\t\t\t\tif(a1 >= HALF_PI) p1 = mpi;\n\t\t\t\tif(a2 >= HALF_PI) p2 = mpi;\n\t\t\t\t\n\t\t\t} else if(np == 2) {\n\t\t\t\tif(debug) console.log(\"P: two vertices\");\n\t\t\t\tif(a1 > 0) {\n\t\t\t\t\tif(a1 + b1 > PI) {\n\t\t\t\t\t\tif(a1 >= HALF_PI) p1 = p2;\n\t\t\t\t\t\tif(b1 >= HALF_PI) q1 = mqi;\n\t\t\t\t\t}\n\t\t\t\t\tif(b2 >= HALF_PI) q2 = mqi;\n\t\t\t\t\tif(a1 < b2 && b2 < HALF_PI) {\n\t\t\t\t\t\tSegment2D p1p2seg = new Segment2D(ps.get(p1), ps.get(p2));\n\t\t\t\t\t\tif(p1p2seg.projectionIsOnSegment(mq)) q2 = mqi;\n\t\t\t\t\t\telse p2 = p1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tp2 = p1;\n\t\t\t\t\tif(b1 >= PI) q1 = mqi;\n\t\t\t\t\tif(b2 >= PI) q2 = mqi;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else if(nq == 2) {\n\t\t\t\tif(debug) console.log(\"Q: two vertices\");\n\t\t\t\tif(b2 > 0) {\n\t\t\t\t\tif(a1 + b1 > PI) {\n\t\t\t\t\t\tif(b1 >= HALF_PI) q1 = q2;\n\t\t\t\t\t\tif(a1 >= HALF_PI) p1 = mpi;\n\t\t\t\t\t}\n\t\t\t\t\tif(a2 >= HALF_PI) p2 = mpi;\n\t\t\t\t\tif(b1 < a2 && a2 < HALF_PI) {\n\t\t\t\t\t\tSegment2D q1q2seg = new Segment2D(qs.get(q1), qs.get(q2));\n\t\t\t\t\t\tif(q1q2seg.projectionIsOnSegment(mp)) p2 = mpi;\n\t\t\t\t\t\telse q2 = q1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tq2 = q1;\n\t\t\t\t\tif(a1 >= PI) p1 = mpi;\n\t\t\t\t\tif(a2 >= PI) p2 = mpi;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else if(a1 >= 0 && a2 >= 0 && b1 >= 0 && b2 >= 0) {\n\t\t\t\tif(debug) console.log(\"> 3 vertices: all angles positive\");\n\t\t\t\tif(a1 + b1 > PI) {\n\t\t\t\t\tif(a1 >= HALF_PI) p1 = mpi;\n\t\t\t\t\tif(b1 >= HALF_PI) q1 = mqi;\n\t\t\t\t}\n\t\t\t\tif(a2 + b2 > PI) {\n\t\t\t\t\tif(a2 >= HALF_PI) p2 = mpi;\n\t\t\t\t\tif(b2 >= HALF_PI) q2 = mqi;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else if(a1 < 0) {\n\t\t\t\tif(debug) console.log(\"> 3 vertices: a1 and a2 negative\");\n\t\t\t\tif(a1 > a2) p2 = mpi;\n\t\t\t\telse p1 = mpi;\n\t\t\t\tif(b1 > PI) q1 = mqi;\n\t\t\t\tif(b2 > PI) q2 = mqi;\n\t\t\t\t\n\n\t\t\t} else if(b1 < 0) {\n\t\t\t\tif(debug) console.log(\"> 3 vertices: b1 and b2 negative\");\n\t\t\t\tif(b1 > b2) q2 = mqi;\n\t\t\t\telse q1 = mqi;\n\t\t\t\tif(a1 > PI) p1 = mpi;\n\t\t\t\tif(a2 > PI) p2 = mpi;\n\t\t\t\t\n\t\t\t}\n\n\t\t\tnp = p2 - p1 + 1;\n\t\t\tnq = q2 - q1 + 1;\n\t\t\t\n\t\t\tif(np >= oldnp && nq >= oldnq) {\n\t\t\t\tif(debug) console.log(\"loop\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t\tif(debug) console.log(oldnp, oldnq, \"->\", np, nq);\n\t\t}\n\t\t\n\t\tif(debug) {\n\t\t\tps.get(p1).label = ps.get(p1).label + \" (P1)\";\n\t\t\tps.get(p2).label = ps.get(p2).label + \" (P2)\";\n\t\t\tqs.get(q1).label = qs.get(q1).label + \" (Q1)\";\n\t\t\tqs.get(q2).label = qs.get(q2).label + \" (Q2)\";\n\t\t}\n\t\t\n\t\tif(np > 2 || nq > 2) return null;\t\t\n\t\t\n\t\tPoint2D p1_ = ps.get(p1), p2_ = ps.get(p2), q1_ = qs.get(q1), q2_ = qs.get(q2);\n\t\tif(p1_ == null || p2_ == null || q1_ == null || q2_ == null) return null;\n\t\t\n\t\tif(np == 1 && nq == 1) {\n\t\t\tif(debug) console.log(\"two vertices\");\n\t\t\treturn new Segment2D(ps.get(p1), qs.get(q1));\n\t\t\t\n\t\t} else if(np == 1) {\n\t\t\tif(debug) console.log(\"edge in Q\");\n\t\t\tPoint2D r, q;\n\t\t\tSegment2D q1q2 = new Segment2D(q1_, q2_);\n\t\t\tif(q1q2.projectionIsOnSegment(p1_)) r = q1q2.projection(p1_); else r = q1_;\n\t\t\t\n\t\t\tfloat d1 = Point2D.sqDistance(q1_, p1_), d2 = Point2D.sqDistance(q2_, p1_), dr = Point2D.sqDistance(r, p1_);\n\t\t\tif(d1 < d2) { if(dr < d1) q = r; else q = q1_; }\n\t\t\telse { if(dr < d2) q = r; else q = q2_; }\n\t\t\t\n\t\t\treturn new Segment2D(p1_, q);\n\t\t\t\n\t\t} else if(nq == 1) {\n\t\t\tif(debug) console.log(\"edge in Q\");\n\t\t\tPoint2D r, p;\n\t\t\tSegment2D p1p2 = new Segment2D(p1_, p2_);\n\t\t\tif(p1p2.projectionIsOnSegment(q1_)) r = p1p2.projection(q1_); else r = p1_;\n\t\t\t\n\t\t\tfloat d1 = Point2D.sqDistance(p1_, q1_), d2 = Point2D.sqDistance(p2_, q1_), dr = Point2D.sqDistance(r, q1_);\n\t\t\tif(d1 < d2) { if(dr < d1) p = r; else p = p1_; }\n\t\t\telse { if(dr < d2) p = r; else p = p2_; }\n\t\t\t\n\t\t\treturn new Segment2D(p, q1_);\n\t\t\t\n\t\t} else {\n\t\t\tif(debug) console.log(\"2 edges\");\n\t\t\tSegment2D q1q2 = new Segment2D(q1_, q2_), p1p2 = new Segment2D(p1_, p2_);\n\t\t\t\n\t\t\tSegment2D[] segs = new Segment2D[8];\n\t\t\tint nseg = 3;\n\t\t\tsegs[0] = new Segment2D(p1_, q1_);\n\t\t\tsegs[1] = new Segment2D(p1_, q2_);\n\t\t\tsegs[2] = new Segment2D(p2_, q1_);\n\t\t\tsegs[3] = new Segment2D(p2_, q2_);\n\t\t\tif(q1q2.projectionIsOnSegment(p1_)) segs[++nseg] = new Segment2D(p1_, q1q2.projection(p1_));\n\t\t\tif(q1q2.projectionIsOnSegment(p2_)) segs[++nseg] = new Segment2D(p2_, q1q2.projection(p2_));\n\t\t\tif(p1p2.projectionIsOnSegment(q1_)) segs[++nseg] = new Segment2D(q1_, p1p2.projection(q1_));\n\t\t\tif(p1p2.projectionIsOnSegment(q2_)) segs[++nseg] = new Segment2D(q2_, p1p2.projection(q2_));\n\n\t\t\tfloat min_d;\n\t\t\tSegment2D min_seg = null;\n\t\t\tfor(int i = 0; i <= nseg; ++i) {\n\t\t\t\tSegment2D seg = segs[i];\n\t\t\t\tfloat d = seg.sqNorm();\n\t\t\t\tif(min_seg == null || d < min_d) { min_d = d; min_seg = seg; }\n\t\t\t}\n\t\t\t\n\t\t\treturn min_seg;\n\t\t}\n\t}\n}\n\nclass Ray2D extends Line2D {\n\tstatic Ray2D fromVector(Point2D o, PVector dir) {\n\t\treturn new Ray2D(o, new Point2D(o.x + dir.x, o.y + dir.y));\n\t}\n\t\n\tRay2D(Point2D na, Point2D nb) {\n\t\tsuper(na, nb);\n\t}\n\t\n\tprotected void draw_() {\t\t\n\t\tnoFill();\n\t\tstroke(strokeColor);\n\n\t\tPoint2D p2 = (a.x < b.x ? pointAtX(width) : pointAtX(0));\n\t\tline(a.x, a.y, p2.x, p2.y);\n\t}\n\t\n\tboolean isUnderMouse() {\n\t\treturn false;\n\t}\n\t\n\tPoint2D lineIntersection(Line2D l) {\n\t\tPoint2D i = super.lineIntersection(l);\n\t\tPVector ia = new PVector(a.x - i.x, a.y - i.y);\n\t\tPVector ba = new PVector(a.x - b.x, a.y - b.y);\n\t\tif(PVector.dot(ia, ba) < 0.0) return null;\n\t\telse return i;\n\t}\n\t\n\tstatic boolean enclosePoints(Ray2D r[], Point2D pt) {\n\t\tPoint2D o = r[0].a;\n\t\tPVector oa = r[0].toPVector();\n\t\tPVector ob = r[1].toPVector();\n\t\tPVector op = new PVector(pt.x - o.x, pt.y - o.y);\n\t\tPVector b = PVector.add(oa, ob);\n\t\t\n\t\tfloat turn1 = PVector.cross(ob, op).z;\n\t\tfloat turn2 = PVector.cross(oa, op).z;\n\t\treturn (turn1*turn2 < 0) && (PVector.dot(op, b) > 0);\n\t}\n}\n\nclass Rectangle2D extends Object2D {\n\tPoint2D origin;\n\tPVector sides;\n\t\n\tRectangle2D(float x, float y, float w, float h) {\n\t\torigin = new Point2D(x, y);\n\t\tsides = new PVector(w, h);\n\t}\n\t\n\tboolean isUnderMouse() {\n\t\tfloat x2 = origin.x + sides.x;\n\t\tfloat y2 = origin.y + sides.y;\n\t\treturn (origin.x <= mouseX) && (x2 >= mouseX) && (origin.y <= mouseY) && (y2 >= mouseY);\n\t}\n\t\n\tPVector center() {\n\t\treturn new PVector(\n\t\t\torigin.position.x + sides.x\/2,\n\t\t\torigin.position.y + sides.y\/2\t\t\n\t\t);\n\t}\n\t\n\tvoid translation(PVector v) {\n\t\torigin.translation(v);\n\t}\n\t\n\tprotected void draw_() {\n\t\tfill(fillColor);\n\t\tstroke(strokeColor);\n\n\t\trect(origin.x, origin.y, sides.x, sides.y);\n\t}\n}\n\nclass Scene {\n\tArrayList objects;\n\tObject2D draggingObject;\n\tPVector dragLastMousePosition;\n\tboolean drawFrame = false;\n\tboolean doUpdate = true;\n\t\n\tScene() {\n\t\tobjects = new ArrayList;\n\t\tnoLoop();\n\t}\n\t\n\tScene add(Object obj) {\n\t\tobjects.add(obj);\n\t\treturn this;\n\t}\n\t\n\tScene addAll(ArrayList objs) {\n\t\tobjects.addAll(objs);\n\t\treturn this;\n\t}\n\t\n\tvoid clear() {\n\t\tobjects = new ArrayList;\n\t\tdraggingObject = null;\n\t}\n\t\n\tvoid draw() {\n\t\tbackground(255);\n\t\tif(doUpdate) for(int i = 0; i < objects.size(); ++i) {\n\t\t\tObject2D updated = objects.get(i).update();\n\t\t\tif(updated != null) objects.set(i, updated);\n\t\t}\n\t\tfor(int i = 0; i < objects.size(); ++i) {\n\t\t\tobjects.get(i).draw();\n\t\t}\n\t\tif(drawFrame) {\n\t\t\tstroke(0); noFill();\n\t\t\trect(0, 0, width - 1, height - 1);\n\t\t}\n\t}\n\t\n\tvoid drag() {\n\t\tif(draggingObject != null && dragLastMousePosition != null) {\n\t\t\tPVector mousePosition = new PVector(mouseX, mouseY);\n\t\t\tPVector offset = PVector.sub(mousePosition, dragLastMousePosition);\n\t\t\tdragLastMousePosition = mousePosition;\n\t\t\tdraggingObject.translation(offset);\n\t\t}\n\t\tredraw();\n\t}\n\t\n\tboolean tick(float dtime) {\n\t\tboolean animation = false;\n\t\tfor(int i = 0; i < objects.size(); ++i) {\n\t\t\tObject2D obj = objects.get(i);\n\t\t\tif(obj.kinetic && obj.velocity != null) {\n\t\t\t\tif(doUpdate) obj.translation(PVector.mult(obj.velocity, dtime));\n\t\t\t\tanimation = true;\n\t\t\t}\n\t\t}\n\t\treturn animation;\n\t}\n\t\n\tObject2D draggableObjectUnderMouse() {\n\t\tfor(int i = 0; i < objects.size(); ++i) {\n\t\t\tObject2D obj = objects.get(i);\n\t\t\tif(obj.draggable && obj.isUnderMouse()) return obj;\n\t\t}\n\t\treturn null;\n\t}\n}\n\n\n\n\nScene scene = new Scene;\nfloat lastTime = 0;\n\nvoid draw() {\n\tfloat time = millis();\n\tfloat dtime = time - lastTime;\n\tlastTime = time;\n\tif(dtime > 500) dtime = 0;\n\t\n\tscene.draw();\n\tboolean animation = scene.tick(dtime);\n\t\n\tif(! animation) noLoop();\n}\n\nvoid mouseMoved() {\n\tObject2D obj = scene.draggableObjectUnderMouse();\n\tif(obj == null) cursor(ARROW);\n\telse cursor(HAND);\n}\n\nvoid mousePressed() {\n\tObject2D obj = scene.draggableObjectUnderMouse();\n\tif(obj == null) {\n\t\tcursor(ARROW);\n\t} else {\n\t\tcursor(HAND);\n\t\tscene.draggingObject = obj;\n\t\tscene.dragLastMousePosition = new PVector(mouseX, mouseY);\n\t}\n}\n\nvoid mouseReleased() {\n\tif(scene.draggingObject) {\n\t\tscene.draggingObject = null;\n\t\tscene.dragLastMousePosition = null;\n\t\tcursor(HAND);\n\t}\n}\n\nvoid mouseDragged() {\n\tscene.drag();\n}\n\nclass Segment2D extends Line2D {\n\tstatic Segment2D fromVector(Point2D o, PVector dir) {\n\t\treturn new Segment2D(o, new Point2D(o.x + dir.x, o.y + dir.y));\n\t}\n\t\n\tSegment2D(Point2D na, Point2D nb) {\n\t\tsuper(na, nb);\n\t}\n\t\n\tprotected void draw_() {\t\t\n\t\tnoFill();\n\t\tstroke(strokeColor);\n\n\t\tline(a.x, a.y, b.x, b.y);\n\t}\n\t\n\tboolean isUnderMouse() {\n\t\treturn super() && projectionIsOnSegment(new Point2D(mouseX, mouseY));\n\t}\n\t\t\n\tfloat norm() {\n\t\treturn sqrt(sqNorm());\n\t}\n\t\n\tfloat sqNorm() {\n\t\treturn sq(a.x - b.x) + sq(a.y - b.y);\n\t}\n\t\n\tPoint2D segmentIntersection(Segment2D seg) {\n\t\tPoint2D i = super.lineIntersection(seg);\n\t\tPVector ia = new PVector(a.x - i.x, a.y - i.y);\n\t\tPVector ib = new PVector(b.x - i.x, b.y - i.y);\n\t\tif(PVector.dot(ia, ib) > 0.0) return null;\n\t\tia = new PVector(seg.a.x - i.x, seg.a.y - i.y);\n\t\tib = new PVector(seg.b.x - i.x, seg.b.y - i.y);\n\t\tif(PVector.dot(ia, ib) > 0.0) return null;\n\t\telse return i;\n\t}\n\t\n\tboolean projectionIsOnSegment(Point2D p) {\n\t\tPVector v = toPVector();\n\t\treturn (PVector.dot(v, Point2D.makePVector(a, p)) > 0 && PVector.dot(v, Point2D.makePVector(b, p)) < 0);\n\t}\n}\n\nint sign(float f) {\n\tif(f > 0.0) return 1;\n\telse if(f < 0.0) return -1;\n\telse return 0;\n}\n\nboolean isUnimodalSequence(ArrayList seq) {\n\tboolean changed = false;\n\tboolean increasing = (seq.get(0) < seq.get(1));\n\tfloat prev = seq.get(1);\n\tfor(int i = 2; i < seq.size(); ++i) {\n\t\tfloat curr = seq.get(i);\n\t\tboolean cmp = (prev < curr);\n\t\tif(cmp != increasing) {\n\t\t\tif(changed) return false;\n\t\t\telse { increasing = cmp; changed = true; }\n\t\t}\n\t\tprev = curr;\n\t}\n\treturn changed;\n}\n\nfloat unimodalSequenceMaximum(ArrayList seq) {\n\t\n}\n\nfloat unimodalSequenceMinimum(ArrayList seq) {\n\t\n}\n\nString formatNumber(float n, int decimals) {\n\tint m = pow(10, decimals);\n\tn *= m;\n\tn = round(n);\n\treturn n \/ m;\n}\n\n";
</script></head>
<body>
	<div class="container">
<div class="navbar navbar-inverse" style="margin-top: 20px">
	<div class="navbar-header">
	  <a class="navbar-brand" href="#">Projet gÃ©omÃ©trie algorithmique: <strong>DÃ©tection de collisions</strong></a>
	</div>
</div>
<div class="navbar navbar-inverse">
	<div class="container">
	  <ul class="nav navbar-nav">
		<li class=""><a href="index.html">Introduction</a></li>
		<li class=""><a href="lp.html">Intersection droiteâpolygone</a></li>
		<li class="active"><a href="pp.html">Intersection polygones</a></li>
		<li class=""><a href="dmin.html">Distance minimale</a></li>
		<li class=""><a href="ref.html">RÃ©fÃ©rences</a></li>
	  </ul>
	</div>
</div>
</div>
	<div class="container">
		<div class="row">
			<div class="col-md-3">
				<ul class="list-group">
					<li class="list-group-item"><a href="#igg"#>Algorithme IGG</a></li>
					<li class="list-group-item"><a href="#init"#>Phase initiale</a></li>
					<li class="list-group-item"><a href="#applet"#>Applet</a></li>
					<li class="list-group-item"><a href="#rec"#>Phase rÃ©cursive</a></li>
				</ul>
			</div>
			<div class="col-md-8">
				<h1>Intersection de deux polygones convexes</h1>
				<p>Par un processus similaire, il est aussi possible de dÃ©terminer une intersection entre deux polygones convexes $P$ et $Q$, en temps $O(\log (n + m))$. (Avec $n$ ne nombre de points de $P$, et $m$ celui de $Q$.) L'algorithme suivant teste s'il y a une intersection de l'intÃ©rieur des polygones, par seulement des segments qui constituent le bord. Ceci est avantageux pour la dÃ©tection de collisions, et en fait on peut montrer qu'un algorithme qui teste seulement une intersection des bords peut seulement avoir une complexitÃ© linÃ©aire.</p>
				
				<h2 id="igg">Algorithme <em>IGG</em></h2>
				<p>Le principe de l'algorithme est de trouver d'abord deux ligne polygonales par les deux polygones, qui s'intersectent si et seulement si les polygones d'intersectent. (Le cas oÃ¹ un polygone serait complÃ¨tement inclut dans l'autre est traitÃ© prÃ©liminairement.) Pour tester cette intersection en temps logarithmique, une procÃ©dure rÃ©cursive est utilisÃ© qui Ã©limine Ã  chaque Ã©tape une moitiÃ© d'une des lignes polynomiales.</p>
				
				<h2 id="init">Phase initiale</h2>
				<p><img src="media/polygons1.svg" align="right" height="220px">Soit $q$ un point quelconque Ã  l'intÃ©rieur de $Q$. Soit $a, b$ les points d'intersection de la droite $(p_1, q)$ et $Q$. (CalculÃ©s en utilisant l'algorithme <em>IGL</em>.) Si $p_1$ se trouve sur le segment $(a, b)$, alors les polygones s'intersectent, et $p_1$ est un point d'intersection. Sinon, soit $(q_i, q_{i+1})$ et $(q_j, q_{j+1})$ les segments de $Q$ sur lesquels $a$ et $b$ se trouvent, respectivement. Par recherche dichotomique, on trouve $t \in j...i+1$ tel que $\angle(p_{1}t, p{1}q)$ est maximal, et $u \in j+1...i$ tel que $\angle(p_{1}q, p{1}u)$ est maximal. Soit $C_1 = (p_{1}u, p_{1}t))$. Tous les points de $Q$ se trouvent dans la section du plan formÃ©e par ces deux demi-droites.<br>
				On applique la mÃªme procÃ©dure pour le polygone $P$ et le point $q_1$, pour trouver les deux demi-droites $C_2$ qui couvrent $P$.</p>
				
				<p><br clear="right"><img src="media/polygons2.svg" align="left" width="300px">Soit $A = p_1$, $B = q_2$, $X, Y$ les point d'intersection de $C_1$ et $C_2$. Si $P$ et $Q$ s'intersectent, cette intersection se trouve nÃ©cessairement Ã  l'intÃ©rieur du quadrilataire $AYBX$: $C_1$ couvre $Q$, $C_2$ couvre $P$, et $AYBX$ est l'intersection des sections du plan couverts par $C_1$ et $C_2$.<br>Il est possible que $C_1$ et $C_2$ contiennent des demi-droite parallÃ¨les et donc soit $X$ ou $Y$ n'existe pas. Dans ce cas on doit former un pentagone, en ajoutant un segment. Ce cas n'est pas traitÃ© ici.<br>
				Ensuite on trouve la ligne polynomiales $L_v = {v_1, v_2, ..., v_n}$ qui compose la partie du bord de $P$ qui est comprise en $C_1$. Donc $v_1$ est le point d'intersection de $AX$ et $P$, $v_n$ le point d'intersection de $AY$ et $P$, et les autre points $v_i$ sont des points $p_i$ de $P$. $L_v$ est pris en sens horlogique. De maniÃ¨re Ã©quivalente, on trouve $L_w$, en sens anti-horlogique, qui donne la partie du bord de $Q$ qui est comprise en $C_2$. (On redÃ©fini $n = |L_v|$ et $m = |L_w|$)</p>
				
				<h2 id="applet">Applet</h2>
				<p>Cet applet implÃ©mente la phase initiale de l'algorithme (trouver les polylignes $L_v$ et $L_w$):</p> 
				<p><canvas id="processing-canvas-1"></canvas><script>
	var js = frameworkJs + "\n\nPolygon2D P, Q;\nPoint2D X, Y;\n\nclass Updater extends Object2D {\n\tRay2D[] pencilP_; \/\/ origin in P, encloses Q\n\tRay2D[] pencilQ_; \/\/ origin in Q, encloses P\n\t\n\tvoid update_() {\n\t\tpencilP_ = null; pencilQ_ = null;\n\t\t\n\t\tpencilP_ = P.pencilOrIntersectionPoint(Q);\n\t\tpencilQ_ = Q.pencilOrIntersectionPoint(P);\n\t}\n\t\n\n\tObject2D update() {\n\t\tboolean convex = true;\t\t\n\t\tif(! P.isConvex()) { P.strokeColor = #FF0000; convex = false; }\n\t\telse P.strokeColor = #000000;\n\t\tif(! Q.isConvex()) { Q.strokeColor = #FF0000; convex = false; }\n\t\telse Q.strokeColor = #000000;\n\t\n\t\tfor(int i = 0; i < P.points.size(); ++i) P.points.get(i).label = null;\n\t\tfor(int i = 0; i < Q.points.size(); ++i) Q.points.get(i).label = null;\n\t\n\t\tif(convex) update_();\n\t\t\n\t\tPoint2D nX = pencilP_[0].lineIntersection(pencilQ_[1]);\n\t\tif(nX != null) { X.x = nX.x; X.y = nX.y; X.visible = true; }\n\t\telse X.visible = false;\n\t\t\n\t\tPoint2D nY = pencilP_[1].lineIntersection(pencilQ_[0]);\n\t\tif(nY != null) { Y.x = nY.x; Y.y = nY.y; Y.visible = true; }\n\t\telse Y.visible = false;\n\t}\n\t\n\tprivate void drawPencil_(Polygon2D poly, Ray2D[] pencil, color pencilCol, color col, String lb, String olb) {\n\t\tif(pencil == null || pencil[0] == null) return;\n\t\tpencil[0].strokeColor = pencilCol;\n\t\tpencil[0].draw();\n\t\tpencil[1].strokeColor = pencilCol;\n\t\tpencil[1].draw();\n\t\t\n\t\tstrokeWeight(3);\n\t\tArrayList pts = poly.pencilOwnPolyline(pencil);\n\t\tfor(int j = 1; j < pts.size(); ++j) {\n\t\t\tSegment2D seg = new Segment2D(pts.get(j-1), pts.get(j));\n\t\t\tseg.strokeColor = col;\n\t\t\tseg.draw();\n\t\t}\n\t\tstrokeWeight(1);\n\t\tfor(int j = 0; j < pts.size(); ++j) {\n\t\t\tPoint2D pt = pts.get(j);\n\t\t\tpt.strokeColor = col;\n\t\t\tpt.label = lb + (j + 1);\n\t\t\tpt.draw();\n\t\t}\n\t\t\n\t\tif(pencil[0].a.label != null) pencil[0].a.label = pencil[0].a.label + \" = \" + olb;\n\t\telse pencil[0].a.label = olb;\n\t\tpencil[0].a.strokeColor = col;\n\t\tpencil[0].a.draw();\n\n\t}\n\t\n\tprotected void draw_() {\n\t\tdrawPencil_(P, pencilP_, color(0, 0, 255, 200), color(0, 0, 255, 255), \"v\", \"A\");\n\t\tdrawPencil_(Q, pencilQ_, color(255, 0, 0, 200), color(255, 0, 0, 555), \"w\", \"B\");\n\t}\n}\n\nvoid setup() {\n\tP = Polygon2D.generateRandomConvexWithMaximalNumberOfPoints(30, new PVector(10, 40), new PVector(240, 260));\n\tQ = Polygon2D.generateRandomConvexWithMaximalNumberOfPoints(100, new PVector(350, 80), new PVector(590, 220));\n\tX = new Point2D(0, 0); X.label = \"X\"; X.draggable = false; X.visible = false;\n\tY = new Point2D(0, 0); Y.label = \"Y\"; Y.draggable = false; Y.visible = false;\n\tP.fillColor = color(0, 0, 0, 20); Q.fillColor = color(0, 0, 0, 20);\n\tP.label = \"P\"; Q.label = \"Q\";\n\tscene.addAll(P.points).addAll(Q.points).add(P).add(Q).add(X).add(Y);\n\n\tscene.add(new Updater);\t\n\n\tsize(600, 300);\n}\n";
	var procedure = Processing.compile(js);
	var canvas = document.getElementById("processing-canvas-1");
	var instance = new Processing(canvas, procedure);
</script>	</p>
				
				<h2 id="rec">Phase rÃ©cursive</h2>
				<p><br clear="left">Les polygones $P$ et $Q$ s'intersectent si et seulement si les deux polylignes $L_v$ et $L_w$ s'intersectent. Si $n, m > 5$, alors au lieu de tester toutes les $n \times m$ possibilitÃ©es de segments de $L_v$ et $L_w$ qui peuvent former l'intersection, l'algorithme rÃ©cursif $\textbf{INTERSECT}(L_v, L_w)$ peut Ãªtre utilisÃ©:</p>
			
				<p><img src="media/igg1.jpg" align="right">On pose $i = \lfloor \frac{n}{2} \rfloor$ et $j = \lfloor \frac{m}{2} \rfloor$. Soit $F, G$ les points d'intersection de $v_{i}v_{i+1}$ et $AYBX$. On choisit $F$ tel que $v_{i+1}$ se trouve sur le segment $v_{i}F$. De la mÃªme maniÃ¨re, soit $E, H$ les points d'intersection de $w_{i}w_{i+1}$ et $AYBX$, oÃ¹ $w_{j+1}$ est sur le segment $w_{j}H$. (voir figure) Ensuite on distingue plusieurs cas:</p>
				
				<p>Soit $x$ la ligne polygonale $AXB$, et $y$ la ligne polygonale $AYB$. Pour deux points $F$ et $G$, la notation $F < G$ sigifie que $F$ et $G$ sont tous les deux sur $x$ ou tous les deux sur $y$, et $F$ prÃ©cÃ¨de $G$ sur le chemin de $A$ Ã  $B$.</p>
				
				<p><strong>Cas 1:</strong> $G$ et $F$ se trouvent au mÃªme cÃ´tÃ© de $AB$ et/ou $E$ et $H$ se trouvent au mÃªme cÃ´tÃ© de $AB$.<br>
				Si $G$ et $F$ sont sur $x$: $L_v \leftarrow \{ v_1, ..., v_{i+1}, v_{n} \}$. Sinon, si $G$ et $F$ sont sur $y$: $L_v \leftarrow \{ v_1, v_{i}, ..., v_{n} \}$. <br>
				De mÃªme, si $E$ et $H$ sont sur $x$, $L_w \leftarrow \{ w_1, w_j, ..., w_m \}$, et si $E$ et $H$ sont sur $y$, $L_w \leftarrow \{ w_1, ..., w_{j+1}, w_{n} \}$.</p>
				
				<p>Explication pour le cas oÃ¹ $G$ et $F$ sont sur $y$ (reprÃ©sentÃ© sur la figure): On peut montrer que si $L_v$ et $L_w$ s'intersectent, alors cette intersection doit Ãªtre sur $\{ v_i, v_{i+1}, ..., v_{n} \}$:<br>
				Comme $G, F \in y$, $P$ se trouve complÃ¨tement au mÃªme cÃ´tÃ© de $GF$ que $X$. Par consÃ©quent, le point d'intersection de $P$ et $BY$ (unique par construction), doit se trouver sur le segment $BF$, et chaque point d'intersection des polylignes est dans $\{ v_i, ..., v_n \}$.
				</p>
				
				<p><br clear="right"><img src="media/igg2.jpg" align="right"><strong>Cas 2:</strong> $F$ et $E$ sont sur $x$, et $G$ et $H$ sont sur $y$.<br>
				Si $F < E$ et $G < H$, il n'y a pas d'intersection des polygones, et l'algorithme se termine.</p>
			
				<p>Soit $V$ l'intersection du polygone dÃ©limitÃ© par $(A, x, FG, y)$ ($AFGY$ sur la figure), et du polygone dÃ©limitÃ© par $(B, x, EH, y)$ ($BHE$ sur la figure).$ L'intersection des polylignes doit de trouver Ã  l'intÃ©rieur de $V$. Pour ce cas ($F < E$ et $G < H$), $V$ est vide, et donc il n'y a pas d'intersection des polylignes.</p>
	
				<p><br clear="right"><img src="media/igg3.jpg" align="right"><strong>Cas 3:</strong> Les segments $GF$ et $EH$ s'intersectent en un point $I$.<br>
				Si $G < H$ et $E < F$: Si $v_i \in GI$, $L_v \leftarrow \{ v_1, v_i, ..., v_n \}$, et si $w_{j+1} \in HI$, $L_w \leftarrow \{ w_1, ..., w_{j+1}, w_m \}$.<br>
				Si $H < G$ et $F < E$: Si $v_{i+1} \in FI$, $L_v \leftarrow \{ v_1, ..., v_{i+1}, v_n \}$, et si $w_j \in EI$, $L_w \leftarrow \{ w_1, w_j, ..., w_m \}$.
				</p>
				
				<p><br clear="right"><img src="media/igg4.jpg" align="right"><strong>Cas 4:</strong> Les segments $Av_i$ et $Vw_j$ s'intersectent.<br>
				Dans ce cas, les polylignes d'intersectent dans le mÃªme point. En fait $Av_i$ et $Vw_j$ se trouvent dans $P$ et $Q$, respectivement, et donc leur intersection est aussi une intersection des deux polygones. (N.B. on cherche une intersection des d'intÃ©rieurs des polygones)</p>
				
				<p><br clear="right"><img src="media/igg5.jpg" align="right"><strong>Cas 5:</strong> Soit $R$ le point d'intersection de $Av_i$ et $HE$.<br>Si $w_j \in ER$: $L_v \leftarrow \{ v_1, v_i, ..., v_n \}$ et $L_w \leftarrow \{ w_1, w_j, ..., w_m \}$.<br>
				Sinon, $L_w \leftarrow \{ v_1, ..., v_{i+1}, v_n \}$ et $L_w \leftarrow \{ w_1, ..., w_{j+1}, w_m \}$.</p>
				
				<p><br clear="right">Tant que $|L_v|, |L_w| > 5$, on appelle rÃ©cursivement $\textbf{INTERSECT}(L_v, L_w)$, avec les nouvelles $L_v$, $L_w$. Comme $L_v$ et/ou $L_w$ ont Ã©tÃ© rÃ©duits Ã  la moitiÃ©, le nombre de rÃ©cursions est limitÃ© par $\log_{2} (n + m)$.</p>
			
				<p>Pour le cas oÃ¹ une des deux polylignes contient moins que 6 points, on peut prouver qu'il est aussi possible de dÃ©tecter les intersections en temps logarithmique, avec un algorithme diffÃ©rent.</p>
			</div>
		</div>
	</div>
</body>
</html>
