<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<title>Détection de collisions</title>
	<link href="media/bootstrap.css" rel="stylesheet">
	<link href="media/style.css" rel="stylesheet">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<script src="media/jquery-2.1.0.min.js"></script>
	<script src="media/bootstrap.js"></script>
	<script type="text/x-mathjax-config">
		MathJax.Hub.Config({
			"tex2jax" : { "inlineMath" : [['$','$'], ['\\(','\\)']] },
			"HTML-CSS" : { "scale" : 85 }
		});
	</script>
	<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
	<script src="media/processing.js"></script>
<script 
<script>
	var frameworkJs = "class Line2D extends Object2D {\n\tPoint2D a;\n\tPoint2D b;\n\n\tLine2D(Point2D na, Point2D nb) {\n\t\ta = na;\n\t\tb = nb;\n\t}\n\n\tstatic Line2D fromVector(Point2D o, PVector dir) {\n\t\treturn new Line2D(a, new Point2D(o.x + dir.x, o.y + dir.y));\n\t}\n\t\n\tPVector direction() {\n\t\tPVector dir = toPVector();\n\t\tdir.normalize();\n\t\treturn dir;\n\t}\n\t\n\tPoint2D firstPoint() {\n\t\treturn a;\n\t}\n\t\n\tPoint2D secondPoint() {\n\t\treturn b;\n\t}\n\t\n\tPVector toPVector() {\n\t\treturn new PVector(b.x - a.x, b.y - a.y);\n\t}\n\t\n\tprotected void draw_() {\t\t\n\t\tnoFill();\n\t\tstroke(strokeColor);\n\n\t\tPoint2D p1 = pointAtX(0);\n\t\tPoint2D p2 = pointAtX(width);\n\t\tline(p1.x, p1.y, p2.x, p2.y);\n\t}\n\t\t\n\tvoid translation(PVector v) {\n\t\ta.translation(v);\n\t\tb.translation(v);\n\t}\n\t\n\tPVector center() {\n\t\treturn new PVector(\n\t\t\ta.x + (b.x - a.x)\/2,\n\t\t\ta.y + (b.y - a.y)\/2\n\t\t);\n\t}\n\t\n\tboolean isXAligned() {\n\t\treturn (a.y == b.y);\n\t}\n\t\n\tboolean isYAligned() {\n\t\treturn (a.x == b.x);\n\t}\n\t\n\tfloat slope() {\n\t\tPVector v = toPVector();\n\t\treturn v.y \/ v.x;\n\t}\n\t\n\tfloat offset() {\n\t\treturn a.y - slope()*a.x;\n\t}\n\t\n\tvoid reverse() {\n\t\tPoint2D tmp = a;\n\t\ta = b;\n\t\tb = tmp;\n\t}\n\t\n\tint side(Point2D p) {\n\t\treturn Point2D.turn(a, b, p);\n\t}\n\t\n\tPoint2D pointAtX(float x) {\n\t\tfloat y = slope()*x + offset();\n\t\treturn new Point2D(x, y);\n\t}\n\t\n\tSegment2D orthogonalRejection(Point2D p) {\n\t\tPVector dir = direction();\n\t\tPVector pa = PVector.sub(a.toPVector(), p.toPVector());\n\t\tfloat projectionLength = pa.dot(dir);\n\t\tPVector projection = PVector.mult(dir, projectionLength);\n\t\tPVector rejection = PVector.sub(pa, projection);\n\t\treturn Segment2D.fromVector(p, rejection);\n\t}\n\t\n\tfloat orthogonalDistance(Point2D p) {\n\t\treturn orthogonalRejection(p).norm();\n\t}\n\t\n\tboolean isUnderMouse() {\n\t\tPoint2D m = new Point2D(mouseX, mouseY);\n\t\treturn (orthogonalDistance(m) <= 3)\n\t}\n\t\n\tfloat orientedOrthogonalDistance(Point2D p, Point2D v) {\n\t\tfloat d = orthogonalDistance(p);\n\t\tif(side(p) != side(v)) return -d;\n\t\treturn d;\n\t}\n\t\n\tPoint2D lineIntersection(Line2D l2) {\n\t\tfloat x1 = a.x, y1 = a.y;\n\t\tfloat x2 = b.x, y2 = b.y;\n\t\tfloat x3 = l2.a.x, y3 = l2.a.y;\n\t\tfloat x4 = l2.b.x, y4 = l2.b.y;\n\t\treturn new Point2D(\n\t\t\t  ( (x1*y2 - y1*x2)*(x3 - x4) - (x1 - x2)*(x3*y4 - y3*x4) )\n\t\t\t\/ ( (x1 - x2)*(y3 - y4) - (y1 - y2)*(x3 - x4) ),\n\t\t\t\n\t\t\t  ( (x1*y2 - y1*x2)*(y3 - y4) - (y1 - y2)*(x3*y4 - y3*x4) )\n\t\t\t\/ ( (x1 - x2)*(y3 - y4) - (y1 - y2)*(x3 - x4) )\n\t\t);\n\t}\n\t\n\tPoint2D projection(Point2D p) {\n\t\tPVector ab = toPVector();\n\t\tPVector ap = Point2D.makePVector(a, p);\n\t\tab.normalize();\n\t\tfloat l = PVector.dot(ab, ap);\n\t\tab.mult(l);\n\t\treturn new Point2D(a.x + ab.x, a.y + ab.y);\n\t}\n}\n\nclass Object2D {\n\tboolean visible;\n\tcolor strokeColor;\n\tString label;\n\tboolean draggable;\n\tboolean kinetic;\n\tPVector velocity;\n\t\n\tObject2D() {\n\t\tvelocity = new PVector(0, 0);\n\t\tdraggable = true;\n\t\tkinetic = false;\n\t\tvisible = true;\n\t\tstrokeColor = color(0);\n\t\tlabel = null;\n\t}\n\t\n\tObject2D update() {\n\t\treturn null;\n\t}\n\t\n\tvoid draw() {\n\t\tif(! visible) return;\n\t\tdraw_();\n\t\tif(label != null) {\n\t\t\tfill(strokeColor);\n\t\t\tPVector c = center();\n\t\t\ttextAlign(CENTER);\n\t\t\ttext(label, c.x + 5, c.y + 10);\n\t\t}\n\t}\n\t\n\tprotected void draw_() { }\n\tPVector center() { return null; }\n\tvoid translation(PVector v) { }\n\t\n\tboolean isUnderMouse() { return false; }\n}\n\nclass Point2D extends Object2D {\n\tfloat x;\n\tfloat y;\n\tPoint2D next;\n\tPoint2D previous;\n\t\n\tstatic Point2D fromPVector(PVector v) {\n\t\treturn new Point2D(v.x, v.y);\n\t}\n\t\n\tstatic Point2D makePVector(Point2D a, Point2D b) {\n\t\treturn new PVector(b.x - a.x, b.y - a.y);\n\t}\n\t\n\tPoint2D(float nx, float ny) {\n\t\tx = nx;\n\t\ty = ny;\n\t}\n\t\n\tprotected void draw_() {\t\t\n\t\tnoStroke();\n\t\tfill(strokeColor);\n\n\t\tellipseMode(CENTER);\n\t\tellipse(x, y, 3, 3);\n\t}\n\t\n\tboolean isUnderMouse() {\n\t\tfloat minOffset = 3;\n\t\tfloat dx = abs(x - mouseX);\n\t\tfloat dy = abs(y - mouseY);\n\t\treturn (dx <= minOffset) && (dy <= minOffset);\n\t}\n\t\n\tPVector center() {\n\t\treturn toPVector();\n\t}\n\t\n\tPVector toPVector() {\n\t\treturn new PVector(x, y);\n\t}\n\t\n\tvoid translation(PVector v) {\n\t\tx += v.x;\n\t\ty += v.y;\n\t}\n\t\n\tstatic int turn(Point2D a, Point2D b, Point2D c) {\n\t\tPVector ba = new PVector(a.x - b.x, a.y - b.y);\n\t\tPVector bc = new PVector(c.x - b.x, c.y - b.y);\n\t\tPVector cross = ba.cross(bc);\n\t\treturn sign(cross.z);\n\t}\n\t\n\tstatic float angle(Point2D a, Point2D b, Point2D c) {\n\t\tPVector ba = new PVector(a.x - b.x, a.y - b.y); ba.normalize();\n\t\tPVector bc = new PVector(c.x - b.x, c.y - b.y); bc.normalize();\n\t\tfloat an = acos(PVector.dot(ba, bc));\n\t\tif(PVector.cross(ba, bc).z < 0) return TWO_PI - an;\n\t\telse return an;\n\t}\n\n\tstatic float sqDistance(Point2D a, Point2D b) {\n\t\tfloat x = a.x - b.x;\n\t\tfloat y = a.y - b.y;\n\t\treturn x*x + y*y;\n\t}\n\t\n\tstatic float distance(Point2D a, Point2D b) {\n\t\treturn sqrt(sqDistance(a, b));\n\t}\n\t\n\tstatic void sortPoints(ArrayList pts, int coordinate, boolean ascending) {\n\t\tboolean cont = false;\n\t\tint lim = pts.size();\n\t\tdo {\n\t\t\tfor(int i = 1; i < lim; ++i) {\n\t\t\t\tPoint2D p1 = pts.get(i - 1);\n\t\t\t\tPoint2D p2 = pts.get(i);\n\t\t\t\tboolean swap = false;\n\t\t\t\tif(coordinate == 0) swap = (p1.x > p2.x);\n\t\t\t\telse if(coordinate == 1) swap = (p1.y > p2.y);\n\t\t\t\tif(! ascending) swap = !swap;\n\t\t\t\tif(swap) {\n\t\t\t\t\tcont = true;\n\t\t\t\t\tpts.set(i - 1, p2);\n\t\t\t\t\tpts.set(i, p1);\n\t\t\t\t}\n\t\t\t}\n\t\t\t--lim;\n\t\t} while(cont && lim);\n\t}\n}\n\nclass Polygon2D extends Object2D {\n\tArrayList points;\n\tboolean hasFillColor;\n\tcolor fillColor;\n\t\n\tstatic Polygon2D generateRandom(int nbPoints, PVector low, PVector high) {\n\t\tPolygon2D poly = new Polygon2D;\n\t\tfor(int i = 0; i < nbPoints; ++i) {\n\t\t\tfloat x = random(low.x, high.x);\n\t\t\tfloat y = random(low.y, high.y);\n\t\t\tPoint2D pt = new Point2D(x, y);\n\t\t\tpoly.points.add(pt);\n\t\t}\n\t\tpoly.linkPoints();\n\t\tpoly.randomShiftPoints();\n\t\treturn poly;\n\t}\n\t\n\tstatic Polygon2D generateRandomConvexWithMaximalNumberOfPoints(int nbPoints, PVector low, PVector high) {\n\t\tPolygon2D poly = Polygon2D.generateRandom(nbPoints, low, high);\n\t\tPolygon2D cpoly = poly.convexHull();\n\t\tcpoly.randomShiftPoints();\n\t\treturn cpoly;\n\t}\n\n\tstatic Polygon2D generateRandomConvex(int nbPoints, PVector low, PVector high) {\n\t\tPolygon2D poly = Polygon2D.generateRandomConvexWithMaximalNumberOfPoints(2 * nbPoints, low, high);\n\t\tfloat m = 2;\n\t\twhile(poly.points.size() < nbPoints) {\n\t\t\tm += 0.5;\n\t\t\tpoly = Polygon2D.generateRandomConvexWithMaximalNumberOfPoints(m * nbPoints, low, high);\n\t\t}\n\t\tfor(int remaining = poly.points.size() - nbPoints; remaining > 0; --remaining) {\n\t\t\tint i = floor(random(0, poly.points.size() - 1));\n\t\t\tpoly.points.remove(i);\n\t\t}\n\t\tpoly.linkPoints();\n\t\treturn poly;\n\t}\n\t\n\tPolygon2D() {\n\t\tpoints = new ArrayList();\n\t}\n\t\n\tPolygon2D(ArrayList pts) {\n\t\tpoints = new ArrayList(pts);\n\t\tlinkPoints();\n\t}\n\t\n\tboolean isConvex() {\n\t\tPoint p1 = points.get(points.size() - 2);\n\t\tPoint p2 = points.get(points.size() - 1);\n\t\tPoint p3 = points.get(0);\n\t\tint need_sign = Point2D.turn(p1, p2, p3);\n\t\tfor(int i = 1; i < points.size(); ++i) {\n\t\t\tp1 = p2;\n\t\t\tp2 = p3;\n\t\t\tp3 = points.get(i);\n\t\t\tint sign = Point2D.turn(p1, p2, p3);\n\t\t\tif(sign != need_sign) return false;\n\t\t}\n\t\treturn true;\n\t}\n\t\n\tvoid linkPoints() {\n\t\tfor(int i = 1; i < points.size(); ++i) {\n\t\t\tpoints.get(i - 1).next = points.get(i);\n\t\t\tpoints.get(i).previous = points.get(i - 1);\n\t\t}\n\t\tpoints.get(points.size() - 1).next = points.get(0);\n\t\tpoints.get(0).previous = points.get(points.size() - 1);\n\t}\n\t\n\tPVector center() {\n\t\tPVector c = new PVector(0, 0);\n\t\tfor(int i = 0; i < points.size(); ++i) {\n\t\t\tc.add(points.get(i).toPVector());\n\t\t}\n\t\tc.div(points.size());\n\t\treturn c;\n\t}\n\t\n\tvoid translation(PVector v) {\n\t\tfor(int i = 0; i < points.size(); ++i) {\n\t\t\tpoints.get(i).translation(v);\n\t\t}\n\t}\n\t\n\tprotected void draw_() {\n\t\tif(hasFillColor) fill(fillColor);\n\t\telse noFill();\n\t\tstroke(strokeColor);\n\n\t\tbeginShape();\n\t\tfor(int i = 0; i < points.size(); ++i) {\n\t\t\tPoint2D pt = points.get(i);\n\t\t\tvertex(pt.x, pt.y);\n\t\t}\n\t\tendShape(CLOSE);\n\t}\n\n\t\n\tPolygon2D convexHull() {\n\t\t\/\/ from http:\/\/www.cs.uu.nl\/docs\/vakken\/ga\/slides1.pdf\n\t\tArrayList pts = new ArrayList(points);\n\t\t\n\t\tPoint2D.sortPoints(pts, 0, true);\n\t\t\t\t\n\t\tArrayList upper = new ArrayList();\n\t\tupper.add(pts.get(0)); upper.add(pts.get(1));\n\t\tfor(int i = 2; i < pts.size(); ++i) {\n\t\t\tupper.add(pts.get(i));\n\t\t\tint l = upper.size() - 1;\n\t\t\twhile(upper.size() > 2 && Point2D.turn(upper.get(l-2), upper.get(l-1), upper.get(l)) > 0) {\n\t\t\t\tupper.remove(l-1);\n\t\t\t\tl = upper.size() - 1;\n\t\t\t}\n\t\t}\n\t\t\t\t\t\t\n\t\tPoint2D.sortPoints(pts, 0, false);\n\t\tArrayList lower = new ArrayList();\n\t\tlower.add(pts.get(0)); lower.add(pts.get(1));\n\t\tfor(int i = 2; i < pts.size(); ++i) {\n\t\t\tlower.add(pts.get(i));\n\t\t\tint l = lower.size() - 1;\n\t\t\twhile(lower.size() > 2 && Point2D.turn(lower.get(l-2), lower.get(l-1), lower.get(l)) > 0) {\n\t\t\t\tlower.remove(l-1);\n\t\t\t\tl = lower.size() - 1;\n\t\t\t}\n\t\t}\n\t\t\n\t\tfor(int i = 1; i < lower.size() - 1; ++i) {\n\t\t\tupper.add(lower.get(i));\n\t\t}\n\t\t\n\t\treturn new Polygon2D(upper);\n\t}\n\t\n\tArrayList segments() {\n\t\tArrayList segments = new ArrayList();\n\t\tfor(int i = 1; i < points.size(); ++i) {\n\t\t\tsegments.add(new Segment2D(points.get(i - 1), points.get(i)));\n\t\t}\n\t\tsegments.add(new Segment2D(points.get(points.size() - 1), points.get(0)));\n\t\treturn segments;\n\t}\n\t\n\tSegment2D segment(int i) {\n\t\ti = i % points.size();\n\t\tif(i < 0) i += points.size();\n\t\tif(i < points.size() - 1) return new Segment2D(points.get(i), points.get(i + 1));\n\t\telse return new Segment2D(points.get(points.size() - 1), points.get(0));\n\t}\n\t\n\tboolean containsPoint(PVector v) {\n\t\tboolean c = false;\n\t\tint j = points.size() - 1;\n\t\tfor(int i = 0; i < points.size(); j = i++) {\n\t\t\tPoint2D pi = points.get(i);\n\t\t\tPoint2D pj = points.get(j);\n\t\t\tif(\n\t\t\t\t((pi.y > v.y) != (pj.y > v.y)) &&\n\t\t\t\t(v.x < (pj.x-pi.x) * (v.y-pi.y) \/ (pj.y-pi.y) + pi.x)\n\t\t\t) c = !c;\n\t\t}\n\t\treturn c;\n\t}\n\t\n\tboolean isUnderMouse() {\n\t\treturn containsPoint(new PVector(mouseX, mouseY));\n\t}\n\t\n\tboolean isClockwise() {\n\t\tfloat sum = 0;\n\t\tArrayList seg = segments();\n\t\tfor(int i = 0; i < seg.size(); ++i) {\n\t\t\tSegment2D s = seg.get(i);\n\t\t\tsum += (s.b.x - s.a.x) * (s.b.y + s.a.y);\n\t\t}\n\t\treturn (sum > 0);\n\t}\n\t\n\tArrayList reversedPoints() {\n\t\tArrayList reversed = new ArrayList;\n\t\tfor(int i = points.size() - 1; i >= 0; --i) {\n\t\t\treversed.add(points.get(i));\n\t\t}\n\t\treturn reversed;\n\t}\n\t\n\tvoid reversePoints() {\n\t\tpoints = reversedPoints();\n\t\tlinkPoints();\n\t}\n\t\n\tvoid shiftPoints(int s) {\n\t\tArrayList newPoints = new ArrayList;\n\t\t\n\t\tfor(int i = 0; i < points.size(); ++i) {\n\t\t\tint j = (i - s) % points.size();\n\t\t\tif(s > i) j += points.size();\n\t\t\tnewPoints.add(points.get(j));\n\t\t}\n\t\tpoints = newPoints;\n\t}\n\t\n\tvoid randomShiftPoints() {\n\t\tshiftPoints(floor(random(1, points.size() - 1)));\n\t}\n\t\n\tfloat pointOrientedDistanceToLine(int i, Line2D line, Point2D v) {\n\t\treturn line.orientedOrthogonalDistance(points.get(i), v);\n\t}\n\t\n\tfloat pointOrientedDistanceToLineG(int i, Line2D line, Point2D v) {\n\t\tfloat f = pointOrientedDistanceToLine(i, line, v);\n\t\tfloat f1 = pointOrientedDistanceToLine(0, line, v);\n\t\tfloat fn = pointOrientedDistanceToLine(points.size() - 1, line, v);\n\t\tfloat t = f1 + (fn - f1)*(i\/(points.size() - 1));\n\t\treturn min(f, t);\n\t}\n\t\n\tfloat segmentPointsOrientedDistancesDifference(int i, Line2D line, Point2D v) {\n\t\tSegment2D seg = segment(i);\n\t\tfloat da = pointOrientedDistanceToLine(i, line, v);\n\t\tfloat db = pointOrientedDistanceToLine((i + 1) % points.size(), line, v);\n\t\treturn db - da;\n\t}\n\t\n\tfloat segmentPointsOrientedDistancesDifferenceG(int i, Line2D line, Point2D v) {\n\t\tSegment2D seg = segment(i);\n\t\tfloat da = pointOrientedDistanceToLineG(i, line, v);\n\t\tfloat db = pointOrientedDistanceToLineG((i + 1) % points.size(), line, v);\n\t\treturn db - da;\n\t}\n\t\n\tfloat lineDistance(Line2D line, Point2D v) {\n\t\tint mn = 0, mx = points.size() - 1;\n\t\twhile(abs(mn - mx) > 1) {\n\t\t\tint i = floor(mn + (mx - mn)\/2);\n\t\t\tfloat dfi = segmentPointsOrientedDistancesDifferenceG(i, line, v);\n\t\t\tif(dfi < 0) mn = i;\n\t\t\telse mx = i;\n\t\t}\n\t\tw = mn + 1;\n\t\treturn pointOrientedDistanceToLine(w, line, v);\n\t}\n\t\n\tint[] lineIntersectionSegmentIndices(Line2D line, Point2D v) {\n\t\tif(v == null) v = points.get(0);\n\t\t\n\t\tfloat f1 = pointOrientedDistanceToLineG(0, line, v);\n\t\tfloat f2 = pointOrientedDistanceToLineG(1, line, v);\n\t\tfloat fn = pointOrientedDistanceToLineG(points.size() - 1, line, v);\n\t\tint w; float fw;\n\t\t\n\t\tint mn = 0, mx = points.size() - 1;\n\t\twhile(abs(mn - mx) > 1) {\n\t\t\tint i = floor(mn + (mx - mn)\/2);\n\t\t\tfloat dfi = segmentPointsOrientedDistancesDifferenceG(i, line, v);\n\t\t\tif(dfi < 0) mn = i;\n\t\t\telse mx = i;\n\t\t}\n\t\tw = mn + 1;\n\t\tfw = pointOrientedDistanceToLine(w, line, v);\n\n\t\tif(fw > 0) {\n\t\t\tint[] inter = {};\n\t\t\treturn inter;\n\t\t} else if(fw == 0) {\n\t\t\tint[] inter = { w };\n\t\t\treturn inter;\n\t\t} else {\n\t\t\tint[] inter = {null, null};\n\n\t\t\tint mn = 0, mx = w;\n\t\t\twhile(abs(mn - mx) > 1) {\n\t\t\t\tint i = floor(mn + (mx - mn)\/2);\n\t\t\t\tfloat fi = pointOrientedDistanceToLine(i, line, v);\n\t\t\t\tif(fi > 0) mn = i;\n\t\t\t\telse mx = i;\n\t\t\t}\n\t\t\tinter[0] = mn;\n\n\t\t\tint mn = w, mx = points.size();\n\t\t\twhile(abs(mn - mx) > 1) {\n\t\t\t\tint i = floor(mn + (mx - mn)\/2);\n\t\t\t\tfloat fi = pointOrientedDistanceToLine(i, line, v);\n\t\t\t\tif(fi < 0) mn = i;\n\t\t\t\telse mx = i;\n\t\t\t}\n\t\t\tinter[1] = mn;\n\t\t\t\n\t\t\treturn inter;\n\t\t}\n\t}\n\t\n\tSegment2D[] lineIntersectionSegments(Line2D l, Point2D v) {\n\t\tint[] segs = lineIntersectionSegmentIndices(l, v);\n\t\tif(segs.length == 0) {\n\t\t\tSegment2D[] segs = {};\n\t\t\treturn segs;\n\t\t} else if(segs.length == 1) {\n\t\t\tSegment2D[] segs = { segment(segs[0]) };\n\t\t\treturn segs;\n\t\t} else if(segs.length == 2) {\n\t\t\tSegment2D[] segs = { segment(segs[0]), segment(segs[1]) };\n\t\t\treturn segs;\n\t\t}\n\t}\n\t\n\tPoint2D[] lineIntersection(Line2D l, Point2D v) {\n\t\tSegment2D[] segs = lineIntersectionSegments(l, v);\n\t\tif(segs.length == 0) {\n\t\t\tPoint2D[] pts = {};\n\t\t\treturn pts;\n\t\t} else if(segs.length == 1) {\n\t\t\tPoint2D[] pts = { segs[0].lineIntersection(l) };\n\t\t\treturn pts;\n\t\t} else if(segs.length == 2) {\n\t\t\tPoint2D[] pts = { segs[0].lineIntersection(l), segs[1].lineIntersection(l) };\n\t\t\treturn pts;\n\t\t}\n\t}\n\t\n\tSegment2D[] rayItersectionSegments(Ray2D r, Point2D v) {\n\t\tSegment2D[] segs = lineIntersectionSegments(r, v);\n\t\tif(segs == null) return null;\n\t\tPoint2D p1 = r.lineIntersection(segs[0]);\n\t\tPoint2D p2 = r.lineIntersection(segs[1]);\n\t\tif(p1 != null && p2 != null) {\n\t\t\treturn segs;\n\t\t} else if(p1 != null) {\n\t\t\tSegment2D[] res = { segs[0] }; return res;\n\t\t} else if(p1 != null) {\n\t\t\tSegment2D[] res = { segs[1] }; return res;\n\t\t}\n\t}\n\t\n\tRay2D[] pencil(Polygon2D Q) {\n\t\tPoint2D qc = Point2D.fromPVector(Q.center());\n\t\tPoint2D p1 = points.get(0);\n\t\tSegment2D[] segs = Q.lineIntersectionSegments(new Line2D(qc, p1));\n\t\tif(segs == null) return null;\n\t\n\t\tPoint2D t, u;\n\t\n\t\tfloat max_a = 0.0;\n\t\tPVector p1qc = new PVector(qc.x - p1.x, qc.y - p1.y);\n\t\tfor(Point2D q = segs[1].b; q != segs[0].a.next; q = q.next) {\n\t\t\tPVector p1q = new PVector(q.x - p1.x, q.y - p1.y);\n\t\t\tfloat a = PVector.angleBetween(p1qc, p1q);\n\t\t\tif(a > max_a) { max_a = a; t = q; }\n\t\t}\n\t\t\n\t\tmax_a = 0.0;\n\t\tfor(Point2D q = segs[0].b; q != segs[1].a.next; q = q.next) {\n\t\t\tPVector p1q = new PVector(q.x - p1.x, q.y - p1.y);\n\t\t\tfloat a = PVector.angleBetween(p1qc, p1q);\n\t\t\tif(a > max_a) { max_a = a; u = q; }\n\t\t}\n\t\t\n\t\tRay2D[] p = {null, null};\n\t\tif(Point2D.turn(t, p1, u) == Point2D.turn(t, t.next, t.next.next)) {\n\t\t\tp[0] = new Ray2D(p1, t); p[1] = new Ray2D(p1, u);\n\t\t} else {\n\t\t\tp[1] = new Ray2D(p1, t); p[0] = new Ray2D(p1, u);\n\t\t}\n\n\t\treturn p;\n\t}\n\t\n\tObject2D[] pencilOrIntersectionPoint(Polygon2D Q) {\n\t\tPoint2D qc = Point2D.fromPVector(Q.center());\n\t\tPoint2D p1 = points.get(0);\n\t\tLine2D l = new Line2D(qc, p1);\n\t\tPoint2D[] ab = Q.lineIntersection(l);\n\t\tPVector p1a = (new Segment2D(p1, ab[0])).toPVector();\n\t\tPVector p1b = (new Segment2D(p1, ab[1])).toPVector();\n\t\tif(PVector.dot(p1a, p1b) < 0) {\n\t\t\tObject2D ret = { null, p1 };\n\t\t\treturn ret;\n\t\t}\n\t\t\n\t\treturn pencil(Q);\n\t}\n\t\n\tint indexModulo(int index) {\n\t\tboolean negative = (index < 0);\n\t\tindex %= points.size();\n\t\tif(negative) index += points.size();\n\t\treturn index;\n\t}\n\n\tArrayList pencilOwnPolyline(Ray2D[] pencil) {\n\t\tif(pencil[0].a != pencil[1].a) { console.log(\"rays don't have same origin\"); return null; }\n\t\tPoint2D o = pencil[0].a; \/\/ == pencil.b\n\t\tPoint2D v = o.next; \/\/ must not be o\n\t\tint n = points.size();\n\t\t\n\t\tint first = -1, last = -1;\n\t\tPoint2D firstp = o, lastp = o;\n\t\t\n\t\tint[] inter1 = lineIntersectionSegmentIndices(pencil[0], v);\n\t\t\n\t\tif(inter1.length == 2) {\n\t\t\tif(inter1[0] == 0 || inter1[0] == n) first = inter1[1];\n\t\t\telse first = inter1[0];\n\n\t\t\tfirstp = segment(first).lineIntersection(pencil[0]);\n\t\t\tif(PVector.dot(pencil[0].toPVector(), Point2D.makePVector(o, firstp)) < 0) {\n\t\t\t\tfirstp = o; first = -1;\n\t\t\t}\n\t\t}\n\n\t\t\n\t\tint[] inter2 = lineIntersectionSegmentIndices(pencil[1], v);\n\t\tif(inter2.length == 2) {\n\t\t\tif(inter2[0] == 0 || inter2[0] == n) last = inter2[1];\n\t\t\telse last = inter2[0];\n\n\t\t\tlastp = segment(last).lineIntersection(pencil[1]);\n\t\t\tif(PVector.dot(pencil[1].toPVector(), Point2D.makePVector(o, lastp)) < 0) {\n\t\t\t\tlastp = o; last = -1;\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\tif(first == -1 && last == -1) {\n\t\t\tif(! Ray2D.enclosePoints(pencil, o.next)) return new ArrayList;\t\t\n\t\t} else if(first == -1) {\n\t\t\tif(Ray2D.enclosePoints(pencil, o.next)) first = 0;\n\t\t\telse first = n;\n\t\t} else if(last == -1) {\n\t\t\tif(Ray2D.enclosePoints(pencil, o.next)) last = 0;\n\t\t\telse last = n;\n\t\t}\n\t\t\n\t\tif(first > last) {\n\t\t\tint tmp = first;\n\t\t\tfirst = last;\n\t\t\tlast = tmp;\n\t\t\tPoint2D tmpp = firstp;\n\t\t\tfirstp = lastp;\n\t\t\tlastp = tmpp;\n\t\t}\n\t\t\n\t\tPoint2D secondp = (first == -1 ? o.next : points.get(indexModulo(first + 1)));\n\t\tPoint2D secondlastp = (last == -1 ? o.previous : points.get(indexModulo(last)));\n\n\t\t\n\t\tArrayList pts = new ArrayList;\n\t\tpts.add(firstp);\n\t\tfor(Point2D pt = secondp; pt != secondlastp.next; pt = pt.next) {\n\t\t\tpts.add(pt);\n\t\t}\n\t\tpts.add(lastp);\n\t\t\n\t\treturn pts;\n\t}\n\t\n\tSegment2D minimalDistance(Polygon2D Q) {\n\t\treturn minimalDistanceDebug(Q, 0, false);\n\t}\n\t\n\tSegment2D minimalDistanceDebug(Polygon2D Q, int steps, boolean debug) {\n\t\tPolygon2D P = this;\n\t\t\n\t\tRay2D[] pencilP = P.pencil(Q);\n\t\tRay2D[] pencilQ = Q.pencil(P);\n\t\t\n\t\tArrayList ps = new ArrayList;\n\t\tfor(Point2D p = pencilQ[0].b; p != pencilQ[1].b.next; p = p.next) ps.add(p);\n\n\t\tArrayList qs = new ArrayList;\n\t\tfor(Point2D q = pencilP[0].b; q != pencilP[1].b.next; q = q.next) qs.add(q);\n\n\t\tint p1 = 0, p2 = ps.size() - 1, np = ps.size();\n\t\tint q1 = 0, q2 = qs.size() - 1, nq = qs.size();\n\n\t\tif(debug) {\n\t\t\tfor(int i = points.size() - 1; i >= 0; --i) { points.get(i).strokeColor = #000000; points.get(i).label = i; }\t\n\t\t\tfor(int i = Q.points.size() - 1; i >= 0; --i) { Q.points.get(i).strokeColor = #000000; Q.points.get(i).label = i; }\n\t\t}\n\t\t\n\t\tint currStep = 0;\n\t\twhile(np > 2 || nq > 2) {\n\t\t\tif(++currStep == steps) break;\n\t\t\t\n\t\t\tint oldnp = np, oldnq = nq;\n\t\t\t\n\t\t\tint mpi = p1 + ceil((p2-p1) \/ 2);\n\t\t\tint mqi = q1 + ceil((q2-q1) \/ 2);\n\t\t\tPoint2D mp = ps.get(mpi);\n\t\t\tPoint2D mq = qs.get(mqi);\n\t\t\tif(mp == null || mq == null) return null;\n\t\t\t\t\t\t\n\t\t\tfloat a1 = Point2D.angle(mq, mp, mp.previous);\n\t\t\tfloat a2 = Point2D.angle(mp.next, mp, mq);\n\t\t\tif(a1 > PI && a2 > PI) { a1 -= TWO_PI; a2 -= TWO_PI; }\n\t\t\t\t\n\t\t\tfloat b1 = Point2D.angle(mq.previous, mq, mp);\n\t\t\tfloat b2 = Point2D.angle(mp, mq, mq.next);\n\t\t\tif(b1 > PI && b2 > PI) { b1 -= TWO_PI; b2 -= TWO_PI; }\n\t\t\t\n\t\t\t\/\/\/\/\/\/\/\/\/\/\/\/ DEBUG \/\/\/\/\/\/\/\/\/\/\/\/\n\t\t\tif(debug && currStep == steps-1) {\n\t\t\t\tSegment2D dseg = new Segment2D(mp, mq);\n\t\t\t\tdseg.label = currStep;\n\t\t\t\tdseg.draw();\t\n\t\n\t\t\t\tps.get(p1).strokeColor = #0000ff;\n\t\t\t\tps.get(p1).label = \"P1\";\n\t\t\t\tps.get(p2).strokeColor = #ff0000;\n\t\t\t\tps.get(p2).label = \"P2\";\n\t\t\t\t\n\t\t\t\tqs.get(q1).strokeColor = #0000ff;\n\t\t\t\tqs.get(q1).label = \"Q1\";\n\t\t\t\tqs.get(q2).strokeColor = #ff0000;\n\t\t\t\tqs.get(q2).label = \"Q2\";\n\t\t\t\t\n\t\t\t\tstroke(50);\n\t\t\t\tfloat d = 180.0 \/ PI;\n\t\t\t\ttextAlign(LEFT);\n\t\t\t\ttext(\"a2 = \" + formatNumber(a2*d, 2), mp.x + 5, mp.y - 15);\n\t\t\t\ttext(\"a1 = \" + formatNumber(a1*d, 2), mp.x + 5, mp.y + 15);\n\t\t\t\ttextAlign(RIGHT);\n\t\t\t\ttext(\"b2 = \" + formatNumber(b2*d, 2), mq.x - 5, mq.y - 15);\n\t\t\t\ttext(\"b1 = \" + formatNumber(b1*d, 2), mq.x - 5, mq.y + 15);\n\t\t\t}\n\t\t\t\/\/\/\/\/\/\/\/\/\/\/\/ END DEBUG \/\/\/\/\/\/\/\/\/\/\/\/\n\n\t\t\tif(np == 1) {\n\t\t\t\tif(debug) console.log(\"P: one vertex\");\n\t\t\t\tif(b1 >= HALF_PI) q1 = mqi;\n\t\t\t\tif(b2 >= HALF_PI) q2 = mqi;\n\t\t\t\t\n\t\t\t} else if(nq == 1) {\n\t\t\t\tif(debug) console.log(\"Q: one vertex\");\n\t\t\t\tif(a1 >= HALF_PI) p1 = mpi;\n\t\t\t\tif(a2 >= HALF_PI) p2 = mpi;\n\t\t\t\t\n\t\t\t} else if(np == 2) {\n\t\t\t\tif(debug) console.log(\"P: two vertices\");\n\t\t\t\tif(a1 > 0) {\n\t\t\t\t\tif(a1 + b1 > PI) {\n\t\t\t\t\t\tif(a1 >= HALF_PI) p1 = p2;\n\t\t\t\t\t\tif(b1 >= HALF_PI) q1 = mqi;\n\t\t\t\t\t}\n\t\t\t\t\tif(b2 >= HALF_PI) q2 = mqi;\n\t\t\t\t\tif(a1 < b2 && b2 < HALF_PI) {\n\t\t\t\t\t\tSegment2D p1p2seg = new Segment2D(ps.get(p1), ps.get(p2));\n\t\t\t\t\t\tif(p1p2seg.projectionIsOnSegment(mq)) q2 = mqi;\n\t\t\t\t\t\telse p2 = p1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tp2 = p1;\n\t\t\t\t\tif(b1 >= PI) q1 = mqi;\n\t\t\t\t\tif(b2 >= PI) q2 = mqi;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else if(nq == 2) {\n\t\t\t\tif(debug) console.log(\"Q: two vertices\");\n\t\t\t\tif(b2 > 0) {\n\t\t\t\t\tif(a1 + b1 > PI) {\n\t\t\t\t\t\tif(b1 >= HALF_PI) q1 = q2;\n\t\t\t\t\t\tif(a1 >= HALF_PI) p1 = mpi;\n\t\t\t\t\t}\n\t\t\t\t\tif(a2 >= HALF_PI) p2 = mpi;\n\t\t\t\t\tif(b1 < a2 && a2 < HALF_PI) {\n\t\t\t\t\t\tSegment2D q1q2seg = new Segment2D(qs.get(q1), qs.get(q2));\n\t\t\t\t\t\tif(q1q2seg.projectionIsOnSegment(mp)) p2 = mpi;\n\t\t\t\t\t\telse q2 = q1;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tq2 = q1;\n\t\t\t\t\tif(a1 >= PI) p1 = mpi;\n\t\t\t\t\tif(a2 >= PI) p2 = mpi;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else if(a1 >= 0 && a2 >= 0 && b1 >= 0 && b2 >= 0) {\n\t\t\t\tif(debug) console.log(\"> 3 vertices: all angles positive\");\n\t\t\t\tif(a1 + b1 > PI) {\n\t\t\t\t\tif(a1 >= HALF_PI) p1 = mpi;\n\t\t\t\t\tif(b1 >= HALF_PI) q1 = mqi;\n\t\t\t\t}\n\t\t\t\tif(a2 + b2 > PI) {\n\t\t\t\t\tif(a2 >= HALF_PI) p2 = mpi;\n\t\t\t\t\tif(b2 >= HALF_PI) q2 = mqi;\n\t\t\t\t}\n\t\t\t\t\n\t\t\t} else if(a1 < 0) {\n\t\t\t\tif(debug) console.log(\"> 3 vertices: a1 and a2 negative\");\n\t\t\t\tif(a1 > a2) p2 = mpi;\n\t\t\t\telse p1 = mpi;\n\t\t\t\tif(b1 > PI) q1 = mqi;\n\t\t\t\tif(b2 > PI) q2 = mqi;\n\t\t\t\t\n\n\t\t\t} else if(b1 < 0) {\n\t\t\t\tif(debug) console.log(\"> 3 vertices: b1 and b2 negative\");\n\t\t\t\tif(b1 > b2) q2 = mqi;\n\t\t\t\telse q1 = mqi;\n\t\t\t\tif(a1 > PI) p1 = mpi;\n\t\t\t\tif(a2 > PI) p2 = mpi;\n\t\t\t\t\n\t\t\t}\n\n\t\t\tnp = p2 - p1 + 1;\n\t\t\tnq = q2 - q1 + 1;\n\t\t\t\n\t\t\tif(np >= oldnp && nq >= oldnq) {\n\t\t\t\tif(debug) console.log(\"loop\");\n\t\t\t\treturn null;\n\t\t\t}\n\t\t\t\n\t\t\tif(debug) console.log(oldnp, oldnq, \"->\", np, nq);\n\t\t}\n\t\t\n\t\tif(debug) {\n\t\t\tps.get(p1).label = ps.get(p1).label + \" (P1)\";\n\t\t\tps.get(p2).label = ps.get(p2).label + \" (P2)\";\n\t\t\tqs.get(q1).label = qs.get(q1).label + \" (Q1)\";\n\t\t\tqs.get(q2).label = qs.get(q2).label + \" (Q2)\";\n\t\t}\n\t\t\n\t\tif(np > 2 || nq > 2) return null;\t\t\n\t\t\n\t\tPoint2D p1_ = ps.get(p1), p2_ = ps.get(p2), q1_ = qs.get(q1), q2_ = qs.get(q2);\n\t\tif(p1_ == null || p2_ == null || q1_ == null || q2_ == null) return null;\n\t\t\n\t\tif(np == 1 && nq == 1) {\n\t\t\tif(debug) console.log(\"two vertices\");\n\t\t\treturn new Segment2D(ps.get(p1), qs.get(q1));\n\t\t\t\n\t\t} else if(np == 1) {\n\t\t\tif(debug) console.log(\"edge in Q\");\n\t\t\tPoint2D r, q;\n\t\t\tSegment2D q1q2 = new Segment2D(q1_, q2_);\n\t\t\tif(q1q2.projectionIsOnSegment(p1_)) r = q1q2.projection(p1_); else r = q1_;\n\t\t\t\n\t\t\tfloat d1 = Point2D.sqDistance(q1_, p1_), d2 = Point2D.sqDistance(q2_, p1_), dr = Point2D.sqDistance(r, p1_);\n\t\t\tif(d1 < d2) { if(dr < d1) q = r; else q = q1_; }\n\t\t\telse { if(dr < d2) q = r; else q = q2_; }\n\t\t\t\n\t\t\treturn new Segment2D(p1_, q);\n\t\t\t\n\t\t} else if(nq == 1) {\n\t\t\tif(debug) console.log(\"edge in Q\");\n\t\t\tPoint2D r, p;\n\t\t\tSegment2D p1p2 = new Segment2D(p1_, p2_);\n\t\t\tif(p1p2.projectionIsOnSegment(q1_)) r = p1p2.projection(q1_); else r = p1_;\n\t\t\t\n\t\t\tfloat d1 = Point2D.sqDistance(p1_, q1_), d2 = Point2D.sqDistance(p2_, q1_), dr = Point2D.sqDistance(r, q1_);\n\t\t\tif(d1 < d2) { if(dr < d1) p = r; else p = p1_; }\n\t\t\telse { if(dr < d2) p = r; else p = p2_; }\n\t\t\t\n\t\t\treturn new Segment2D(p, q1_);\n\t\t\t\n\t\t} else {\n\t\t\tif(debug) console.log(\"2 edges\");\n\t\t\tSegment2D q1q2 = new Segment2D(q1_, q2_), p1p2 = new Segment2D(p1_, p2_);\n\t\t\t\n\t\t\tSegment2D[] segs = new Segment2D[8];\n\t\t\tint nseg = 3;\n\t\t\tsegs[0] = new Segment2D(p1_, q1_);\n\t\t\tsegs[1] = new Segment2D(p1_, q2_);\n\t\t\tsegs[2] = new Segment2D(p2_, q1_);\n\t\t\tsegs[3] = new Segment2D(p2_, q2_);\n\t\t\tif(q1q2.projectionIsOnSegment(p1_)) segs[++nseg] = new Segment2D(p1_, q1q2.projection(p1_));\n\t\t\tif(q1q2.projectionIsOnSegment(p2_)) segs[++nseg] = new Segment2D(p2_, q1q2.projection(p2_));\n\t\t\tif(p1p2.projectionIsOnSegment(q1_)) segs[++nseg] = new Segment2D(q1_, p1p2.projection(q1_));\n\t\t\tif(p1p2.projectionIsOnSegment(q2_)) segs[++nseg] = new Segment2D(q2_, p1p2.projection(q2_));\n\n\t\t\tfloat min_d;\n\t\t\tSegment2D min_seg = null;\n\t\t\tfor(int i = 0; i <= nseg; ++i) {\n\t\t\t\tSegment2D seg = segs[i];\n\t\t\t\tfloat d = seg.sqNorm();\n\t\t\t\tif(min_seg == null || d < min_d) { min_d = d; min_seg = seg; }\n\t\t\t}\n\t\t\t\n\t\t\treturn min_seg;\n\t\t}\n\t}\n}\n\nclass Ray2D extends Line2D {\n\tstatic Ray2D fromVector(Point2D o, PVector dir) {\n\t\treturn new Ray2D(o, new Point2D(o.x + dir.x, o.y + dir.y));\n\t}\n\t\n\tRay2D(Point2D na, Point2D nb) {\n\t\tsuper(na, nb);\n\t}\n\t\n\tprotected void draw_() {\t\t\n\t\tnoFill();\n\t\tstroke(strokeColor);\n\n\t\tPoint2D p2 = (a.x < b.x ? pointAtX(width) : pointAtX(0));\n\t\tline(a.x, a.y, p2.x, p2.y);\n\t}\n\t\n\tboolean isUnderMouse() {\n\t\treturn false;\n\t}\n\t\n\tPoint2D lineIntersection(Line2D l) {\n\t\tPoint2D i = super.lineIntersection(l);\n\t\tPVector ia = new PVector(a.x - i.x, a.y - i.y);\n\t\tPVector ba = new PVector(a.x - b.x, a.y - b.y);\n\t\tif(PVector.dot(ia, ba) < 0.0) return null;\n\t\telse return i;\n\t}\n\t\n\tstatic boolean enclosePoints(Ray2D r[], Point2D pt) {\n\t\tPoint2D o = r[0].a;\n\t\tPVector oa = r[0].toPVector();\n\t\tPVector ob = r[1].toPVector();\n\t\tPVector op = new PVector(pt.x - o.x, pt.y - o.y);\n\t\tPVector b = PVector.add(oa, ob);\n\t\t\n\t\tfloat turn1 = PVector.cross(ob, op).z;\n\t\tfloat turn2 = PVector.cross(oa, op).z;\n\t\treturn (turn1*turn2 < 0) && (PVector.dot(op, b) > 0);\n\t}\n}\n\nclass Rectangle2D extends Object2D {\n\tPoint2D origin;\n\tPVector sides;\n\t\n\tRectangle2D(float x, float y, float w, float h) {\n\t\torigin = new Point2D(x, y);\n\t\tsides = new PVector(w, h);\n\t}\n\t\n\tboolean isUnderMouse() {\n\t\tfloat x2 = origin.x + sides.x;\n\t\tfloat y2 = origin.y + sides.y;\n\t\treturn (origin.x <= mouseX) && (x2 >= mouseX) && (origin.y <= mouseY) && (y2 >= mouseY);\n\t}\n\t\n\tPVector center() {\n\t\treturn new PVector(\n\t\t\torigin.position.x + sides.x\/2,\n\t\t\torigin.position.y + sides.y\/2\t\t\n\t\t);\n\t}\n\t\n\tvoid translation(PVector v) {\n\t\torigin.translation(v);\n\t}\n\t\n\tprotected void draw_() {\n\t\tfill(fillColor);\n\t\tstroke(strokeColor);\n\n\t\trect(origin.x, origin.y, sides.x, sides.y);\n\t}\n}\n\nclass Scene {\n\tArrayList objects;\n\tObject2D draggingObject;\n\tPVector dragLastMousePosition;\n\tboolean drawFrame = false;\n\tboolean doUpdate = true;\n\t\n\tScene() {\n\t\tobjects = new ArrayList;\n\t\tnoLoop();\n\t}\n\t\n\tScene add(Object obj) {\n\t\tobjects.add(obj);\n\t\treturn this;\n\t}\n\t\n\tScene addAll(ArrayList objs) {\n\t\tobjects.addAll(objs);\n\t\treturn this;\n\t}\n\t\n\tvoid clear() {\n\t\tobjects = new ArrayList;\n\t\tdraggingObject = null;\n\t}\n\t\n\tvoid draw() {\n\t\tbackground(255);\n\t\tif(doUpdate) for(int i = 0; i < objects.size(); ++i) {\n\t\t\tObject2D updated = objects.get(i).update();\n\t\t\tif(updated != null) objects.set(i, updated);\n\t\t}\n\t\tfor(int i = 0; i < objects.size(); ++i) {\n\t\t\tobjects.get(i).draw();\n\t\t}\n\t\tif(drawFrame) {\n\t\t\tstroke(0); noFill();\n\t\t\trect(0, 0, width - 1, height - 1);\n\t\t}\n\t}\n\t\n\tvoid drag() {\n\t\tif(draggingObject != null && dragLastMousePosition != null) {\n\t\t\tPVector mousePosition = new PVector(mouseX, mouseY);\n\t\t\tPVector offset = PVector.sub(mousePosition, dragLastMousePosition);\n\t\t\tdragLastMousePosition = mousePosition;\n\t\t\tdraggingObject.translation(offset);\n\t\t}\n\t\tredraw();\n\t}\n\t\n\tboolean tick(float dtime) {\n\t\tboolean animation = false;\n\t\tfor(int i = 0; i < objects.size(); ++i) {\n\t\t\tObject2D obj = objects.get(i);\n\t\t\tif(obj.kinetic && obj.velocity != null) {\n\t\t\t\tif(doUpdate) obj.translation(PVector.mult(obj.velocity, dtime));\n\t\t\t\tanimation = true;\n\t\t\t}\n\t\t}\n\t\treturn animation;\n\t}\n\t\n\tObject2D draggableObjectUnderMouse() {\n\t\tfor(int i = 0; i < objects.size(); ++i) {\n\t\t\tObject2D obj = objects.get(i);\n\t\t\tif(obj.draggable && obj.isUnderMouse()) return obj;\n\t\t}\n\t\treturn null;\n\t}\n}\n\n\n\n\nScene scene = new Scene;\nfloat lastTime = 0;\n\nvoid draw() {\n\tfloat time = millis();\n\tfloat dtime = time - lastTime;\n\tlastTime = time;\n\tif(dtime > 500) dtime = 0;\n\t\n\tscene.draw();\n\tboolean animation = scene.tick(dtime);\n\t\n\tif(! animation) noLoop();\n}\n\nvoid mouseMoved() {\n\tObject2D obj = scene.draggableObjectUnderMouse();\n\tif(obj == null) cursor(ARROW);\n\telse cursor(HAND);\n}\n\nvoid mousePressed() {\n\tObject2D obj = scene.draggableObjectUnderMouse();\n\tif(obj == null) {\n\t\tcursor(ARROW);\n\t} else {\n\t\tcursor(HAND);\n\t\tscene.draggingObject = obj;\n\t\tscene.dragLastMousePosition = new PVector(mouseX, mouseY);\n\t}\n}\n\nvoid mouseReleased() {\n\tif(scene.draggingObject) {\n\t\tscene.draggingObject = null;\n\t\tscene.dragLastMousePosition = null;\n\t\tcursor(HAND);\n\t}\n}\n\nvoid mouseDragged() {\n\tscene.drag();\n}\n\nclass Segment2D extends Line2D {\n\tstatic Segment2D fromVector(Point2D o, PVector dir) {\n\t\treturn new Segment2D(o, new Point2D(o.x + dir.x, o.y + dir.y));\n\t}\n\t\n\tSegment2D(Point2D na, Point2D nb) {\n\t\tsuper(na, nb);\n\t}\n\t\n\tprotected void draw_() {\t\t\n\t\tnoFill();\n\t\tstroke(strokeColor);\n\n\t\tline(a.x, a.y, b.x, b.y);\n\t}\n\t\n\tboolean isUnderMouse() {\n\t\treturn super() && projectionIsOnSegment(new Point2D(mouseX, mouseY));\n\t}\n\t\t\n\tfloat norm() {\n\t\treturn sqrt(sqNorm());\n\t}\n\t\n\tfloat sqNorm() {\n\t\treturn sq(a.x - b.x) + sq(a.y - b.y);\n\t}\n\t\n\tPoint2D segmentIntersection(Segment2D seg) {\n\t\tPoint2D i = super.lineIntersection(seg);\n\t\tPVector ia = new PVector(a.x - i.x, a.y - i.y);\n\t\tPVector ib = new PVector(b.x - i.x, b.y - i.y);\n\t\tif(PVector.dot(ia, ib) > 0.0) return null;\n\t\tia = new PVector(seg.a.x - i.x, seg.a.y - i.y);\n\t\tib = new PVector(seg.b.x - i.x, seg.b.y - i.y);\n\t\tif(PVector.dot(ia, ib) > 0.0) return null;\n\t\telse return i;\n\t}\n\t\n\tboolean projectionIsOnSegment(Point2D p) {\n\t\tPVector v = toPVector();\n\t\treturn (PVector.dot(v, Point2D.makePVector(a, p)) > 0 && PVector.dot(v, Point2D.makePVector(b, p)) < 0);\n\t}\n}\n\nint sign(float f) {\n\tif(f > 0.0) return 1;\n\telse if(f < 0.0) return -1;\n\telse return 0;\n}\n\nboolean isUnimodalSequence(ArrayList seq) {\n\tboolean changed = false;\n\tboolean increasing = (seq.get(0) < seq.get(1));\n\tfloat prev = seq.get(1);\n\tfor(int i = 2; i < seq.size(); ++i) {\n\t\tfloat curr = seq.get(i);\n\t\tboolean cmp = (prev < curr);\n\t\tif(cmp != increasing) {\n\t\t\tif(changed) return false;\n\t\t\telse { increasing = cmp; changed = true; }\n\t\t}\n\t\tprev = curr;\n\t}\n\treturn changed;\n}\n\nfloat unimodalSequenceMaximum(ArrayList seq) {\n\t\n}\n\nfloat unimodalSequenceMinimum(ArrayList seq) {\n\t\n}\n\nString formatNumber(float n, int decimals) {\n\tint m = pow(10, decimals);\n\tn *= m;\n\tn = round(n);\n\treturn n \/ m;\n}\n\n";
</script></head>
<body>
	<div class="container">
<div class="navbar navbar-inverse" style="margin-top: 20px">
	<div class="navbar-header">
	  <a class="navbar-brand" href="#">Projet géométrie algorithmique: <strong>Détection de collisions</strong></a>
	</div>
</div>
<div class="navbar navbar-inverse">
	<div class="container">
	  <ul class="nav navbar-nav">
		<li class=""><a href="index.html">Introduction</a></li>
		<li class=""><a href="lp.html">Intersection droite–polygone</a></li>
		<li class="active"><a href="pp.html">Intersection polygones</a></li>
		<li class=""><a href="dmin.html">Distance minimale</a></li>
		<li class=""><a href="ref.html">Références</a></li>
	  </ul>
	</div>
</div>
</div>
	<div class="container">
		<div class="row">
			<div class="col-md-3">
				<ul class="list-group">
					<li class="list-group-item"><a href="#igg"#>Algorithme IGG</a></li>
					<li class="list-group-item"><a href="#init"#>Phase initiale</a></li>
					<li class="list-group-item"><a href="#applet"#>Applet</a></li>
					<li class="list-group-item"><a href="#rec"#>Phase récursive</a></li>
				</ul>
			</div>
			<div class="col-md-8">
				<h1>Intersection de deux polygones convexes</h1>
				<p>Par un processus similaire, il est aussi possible de déterminer une intersection entre deux polygones convexes $P$ et $Q$, en temps $O(\log (n + m))$. (Avec $n$ ne nombre de points de $P$, et $m$ celui de $Q$.) L'algorithme suivant teste s'il y a une intersection de l'intérieur des polygones, par seulement des segments qui constituent le bord. Ceci est avantageux pour la détection de collisions, et en fait on peut montrer qu'un algorithme qui teste seulement une intersection des bords peut seulement avoir une complexité linéaire.</p>
				
				<h2 id="igg">Algorithme <em>IGG</em></h2>
				<p>Le principe de l'algorithme est de trouver d'abord deux ligne polygonales par les deux polygones, qui s'intersectent si et seulement si les polygones d'intersectent. (Le cas où un polygone serait complètement inclut dans l'autre est traité préliminairement.) Pour tester cette intersection en temps logarithmique, une procédure récursive est utilisé qui élimine à chaque étape une moitié d'une des lignes polynomiales.</p>
				
				<h2 id="init">Phase initiale</h2>
				<p><img src="media/polygons1.svg" align="right" height="220px">Soit $q$ un point quelconque à l'intérieur de $Q$. Soit $a, b$ les points d'intersection de la droite $(p_1, q)$ et $Q$. (Calculés en utilisant l'algorithme <em>IGL</em>.) Si $p_1$ se trouve sur le segment $(a, b)$, alors les polygones s'intersectent, et $p_1$ est un point d'intersection. Sinon, soit $(q_i, q_{i+1})$ et $(q_j, q_{j+1})$ les segments de $Q$ sur lesquels $a$ et $b$ se trouvent, respectivement. Par recherche dichotomique, on trouve $t \in j...i+1$ tel que $\angle(p_{1}t, p{1}q)$ est maximal, et $u \in j+1...i$ tel que $\angle(p_{1}q, p{1}u)$ est maximal. Soit $C_1 = (p_{1}u, p_{1}t))$. Tous les points de $Q$ se trouvent dans la section du plan formée par ces deux demi-droites.<br>
				On applique la même procédure pour le polygone $P$ et le point $q_1$, pour trouver les deux demi-droites $C_2$ qui couvrent $P$.</p>
				
				<p><br clear="right"><img src="media/polygons2.svg" align="left" width="300px">Soit $A = p_1$, $B = q_2$, $X, Y$ les point d'intersection de $C_1$ et $C_2$. Si $P$ et $Q$ s'intersectent, cette intersection se trouve nécessairement à l'intérieur du quadrilataire $AYBX$: $C_1$ couvre $Q$, $C_2$ couvre $P$, et $AYBX$ est l'intersection des sections du plan couverts par $C_1$ et $C_2$.<br>Il est possible que $C_1$ et $C_2$ contiennent des demi-droite parallèles et donc soit $X$ ou $Y$ n'existe pas. Dans ce cas on doit former un pentagone, en ajoutant un segment. Ce cas n'est pas traité ici.<br>
				Ensuite on trouve la ligne polynomiales $L_v = {v_1, v_2, ..., v_n}$ qui compose la partie du bord de $P$ qui est comprise en $C_1$. Donc $v_1$ est le point d'intersection de $AX$ et $P$, $v_n$ le point d'intersection de $AY$ et $P$, et les autre points $v_i$ sont des points $p_i$ de $P$. $L_v$ est pris en sens horlogique. De manière équivalente, on trouve $L_w$, en sens anti-horlogique, qui donne la partie du bord de $Q$ qui est comprise en $C_2$. (On redéfini $n = |L_v|$ et $m = |L_w|$)</p>
				
				<h2 id="applet">Applet</h2>
				<p>Cet applet implémente la phase initiale de l'algorithme (trouver les polylignes $L_v$ et $L_w$):</p> 
				<p><canvas id="processing-canvas-1"></canvas><script>
	var js = frameworkJs + "\n\nPolygon2D P, Q;\nPoint2D X, Y;\n\nclass Updater extends Object2D {\n\tRay2D[] pencilP_; \/\/ origin in P, encloses Q\n\tRay2D[] pencilQ_; \/\/ origin in Q, encloses P\n\t\n\tvoid update_() {\n\t\tpencilP_ = null; pencilQ_ = null;\n\t\t\n\t\tpencilP_ = P.pencilOrIntersectionPoint(Q);\n\t\tpencilQ_ = Q.pencilOrIntersectionPoint(P);\n\t}\n\t\n\n\tObject2D update() {\n\t\tboolean convex = true;\t\t\n\t\tif(! P.isConvex()) { P.strokeColor = #FF0000; convex = false; }\n\t\telse P.strokeColor = #000000;\n\t\tif(! Q.isConvex()) { Q.strokeColor = #FF0000; convex = false; }\n\t\telse Q.strokeColor = #000000;\n\t\n\t\tfor(int i = 0; i < P.points.size(); ++i) P.points.get(i).label = null;\n\t\tfor(int i = 0; i < Q.points.size(); ++i) Q.points.get(i).label = null;\n\t\n\t\tif(convex) update_();\n\t\t\n\t\tPoint2D nX = pencilP_[0].lineIntersection(pencilQ_[1]);\n\t\tif(nX != null) { X.x = nX.x; X.y = nX.y; X.visible = true; }\n\t\telse X.visible = false;\n\t\t\n\t\tPoint2D nY = pencilP_[1].lineIntersection(pencilQ_[0]);\n\t\tif(nY != null) { Y.x = nY.x; Y.y = nY.y; Y.visible = true; }\n\t\telse Y.visible = false;\n\t}\n\t\n\tprivate void drawPencil_(Polygon2D poly, Ray2D[] pencil, color pencilCol, color col, String lb, String olb) {\n\t\tif(pencil == null || pencil[0] == null) return;\n\t\tpencil[0].strokeColor = pencilCol;\n\t\tpencil[0].draw();\n\t\tpencil[1].strokeColor = pencilCol;\n\t\tpencil[1].draw();\n\t\t\n\t\tstrokeWeight(3);\n\t\tArrayList pts = poly.pencilOwnPolyline(pencil);\n\t\tfor(int j = 1; j < pts.size(); ++j) {\n\t\t\tSegment2D seg = new Segment2D(pts.get(j-1), pts.get(j));\n\t\t\tseg.strokeColor = col;\n\t\t\tseg.draw();\n\t\t}\n\t\tstrokeWeight(1);\n\t\tfor(int j = 0; j < pts.size(); ++j) {\n\t\t\tPoint2D pt = pts.get(j);\n\t\t\tpt.strokeColor = col;\n\t\t\tpt.label = lb + (j + 1);\n\t\t\tpt.draw();\n\t\t}\n\t\t\n\t\tif(pencil[0].a.label != null) pencil[0].a.label = pencil[0].a.label + \" = \" + olb;\n\t\telse pencil[0].a.label = olb;\n\t\tpencil[0].a.strokeColor = col;\n\t\tpencil[0].a.draw();\n\n\t}\n\t\n\tprotected void draw_() {\n\t\tdrawPencil_(P, pencilP_, color(0, 0, 255, 200), color(0, 0, 255, 255), \"v\", \"A\");\n\t\tdrawPencil_(Q, pencilQ_, color(255, 0, 0, 200), color(255, 0, 0, 555), \"w\", \"B\");\n\t}\n}\n\nvoid setup() {\n\tP = Polygon2D.generateRandomConvexWithMaximalNumberOfPoints(30, new PVector(10, 40), new PVector(240, 260));\n\tQ = Polygon2D.generateRandomConvexWithMaximalNumberOfPoints(100, new PVector(350, 80), new PVector(590, 220));\n\tX = new Point2D(0, 0); X.label = \"X\"; X.draggable = false; X.visible = false;\n\tY = new Point2D(0, 0); Y.label = \"Y\"; Y.draggable = false; Y.visible = false;\n\tP.fillColor = color(0, 0, 0, 20); Q.fillColor = color(0, 0, 0, 20);\n\tP.label = \"P\"; Q.label = \"Q\";\n\tscene.addAll(P.points).addAll(Q.points).add(P).add(Q).add(X).add(Y);\n\n\tscene.add(new Updater);\t\n\n\tsize(600, 300);\n}\n";
	var procedure = Processing.compile(js);
	var canvas = document.getElementById("processing-canvas-1");
	var instance = new Processing(canvas, procedure);
</script>	</p>
				
				<h2 id="rec">Phase récursive</h2>
				<p><br clear="left">Les polygones $P$ et $Q$ s'intersectent si et seulement si les deux polylignes $L_v$ et $L_w$ s'intersectent. Si $n, m > 5$, alors au lieu de tester toutes les $n \times m$ possibilitées de segments de $L_v$ et $L_w$ qui peuvent former l'intersection, l'algorithme récursif $\textbf{INTERSECT}(L_v, L_w)$ peut être utilisé:</p>
			
				<p><img src="media/igg1.jpg" align="right">On pose $i = \lfloor \frac{n}{2} \rfloor$ et $j = \lfloor \frac{m}{2} \rfloor$. Soit $F, G$ les points d'intersection de $v_{i}v_{i+1}$ et $AYBX$. On choisit $F$ tel que $v_{i+1}$ se trouve sur le segment $v_{i}F$. De la même manière, soit $E, H$ les points d'intersection de $w_{i}w_{i+1}$ et $AYBX$, où $w_{j+1}$ est sur le segment $w_{j}H$. (voir figure) Ensuite on distingue plusieurs cas:</p>
				
				<p>Soit $x$ la ligne polygonale $AXB$, et $y$ la ligne polygonale $AYB$. Pour deux points $F$ et $G$, la notation $F < G$ sigifie que $F$ et $G$ sont tous les deux sur $x$ ou tous les deux sur $y$, et $F$ précède $G$ sur le chemin de $A$ à $B$.</p>
				
				<p><strong>Cas 1:</strong> $G$ et $F$ se trouvent au même côté de $AB$ et/ou $E$ et $H$ se trouvent au même côté de $AB$.<br>
				Si $G$ et $F$ sont sur $x$: $L_v \leftarrow \{ v_1, ..., v_{i+1}, v_{n} \}$. Sinon, si $G$ et $F$ sont sur $y$: $L_v \leftarrow \{ v_1, v_{i}, ..., v_{n} \}$. <br>
				De même, si $E$ et $H$ sont sur $x$, $L_w \leftarrow \{ w_1, w_j, ..., w_m \}$, et si $E$ et $H$ sont sur $y$, $L_w \leftarrow \{ w_1, ..., w_{j+1}, w_{n} \}$.</p>
				
				<p>Explication pour le cas où $G$ et $F$ sont sur $y$ (représenté sur la figure): On peut montrer que si $L_v$ et $L_w$ s'intersectent, alors cette intersection doit être sur $\{ v_i, v_{i+1}, ..., v_{n} \}$:<br>
				Comme $G, F \in y$, $P$ se trouve complètement au même côté de $GF$ que $X$. Par conséquent, le point d'intersection de $P$ et $BY$ (unique par construction), doit se trouver sur le segment $BF$, et chaque point d'intersection des polylignes est dans $\{ v_i, ..., v_n \}$.
				</p>
				
				<p><br clear="right"><img src="media/igg2.jpg" align="right"><strong>Cas 2:</strong> $F$ et $E$ sont sur $x$, et $G$ et $H$ sont sur $y$.<br>
				Si $F < E$ et $G < H$, il n'y a pas d'intersection des polygones, et l'algorithme se termine.</p>
			
				<p>Soit $V$ l'intersection du polygone délimité par $(A, x, FG, y)$ ($AFGY$ sur la figure), et du polygone délimité par $(B, x, EH, y)$ ($BHE$ sur la figure).$ L'intersection des polylignes doit de trouver à l'intérieur de $V$. Pour ce cas ($F < E$ et $G < H$), $V$ est vide, et donc il n'y a pas d'intersection des polylignes.</p>
	
				<p><br clear="right"><img src="media/igg3.jpg" align="right"><strong>Cas 3:</strong> Les segments $GF$ et $EH$ s'intersectent en un point $I$.<br>
				Si $G < H$ et $E < F$: Si $v_i \in GI$, $L_v \leftarrow \{ v_1, v_i, ..., v_n \}$, et si $w_{j+1} \in HI$, $L_w \leftarrow \{ w_1, ..., w_{j+1}, w_m \}$.<br>
				Si $H < G$ et $F < E$: Si $v_{i+1} \in FI$, $L_v \leftarrow \{ v_1, ..., v_{i+1}, v_n \}$, et si $w_j \in EI$, $L_w \leftarrow \{ w_1, w_j, ..., w_m \}$.
				</p>
				
				<p><br clear="right"><img src="media/igg4.jpg" align="right"><strong>Cas 4:</strong> Les segments $Av_i$ et $Vw_j$ s'intersectent.<br>
				Dans ce cas, les polylignes d'intersectent dans le même point. En fait $Av_i$ et $Vw_j$ se trouvent dans $P$ et $Q$, respectivement, et donc leur intersection est aussi une intersection des deux polygones. (N.B. on cherche une intersection des d'intérieurs des polygones)</p>
				
				<p><br clear="right"><img src="media/igg5.jpg" align="right"><strong>Cas 5:</strong> Soit $R$ le point d'intersection de $Av_i$ et $HE$.<br>Si $w_j \in ER$: $L_v \leftarrow \{ v_1, v_i, ..., v_n \}$ et $L_w \leftarrow \{ w_1, w_j, ..., w_m \}$.<br>
				Sinon, $L_w \leftarrow \{ v_1, ..., v_{i+1}, v_n \}$ et $L_w \leftarrow \{ w_1, ..., w_{j+1}, w_m \}$.</p>
				
				<p><br clear="right">Tant que $|L_v|, |L_w| > 5$, on appelle récursivement $\textbf{INTERSECT}(L_v, L_w)$, avec les nouvelles $L_v$, $L_w$. Comme $L_v$ et/ou $L_w$ ont été réduits à la moitié, le nombre de récursions est limité par $\log_{2} (n + m)$.</p>
			
				<p>Pour le cas où une des deux polylignes contient moins que 6 points, on peut prouver qu'il est aussi possible de détecter les intersections en temps logarithmique, avec un algorithme différent.</p>
			</div>
		</div>
	</div>
</body>
</html>
